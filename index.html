<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>LISP</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/css/reset.css">
  <link rel="stylesheet" href="./reveal.js/css/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./reveal.js/css/theme/simple.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? './reveal.js/css/print/pdf.css' : './reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="./reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">LISP</h1>
  <p class="author"><div class="line-block">del Mazo, Federico - 100029<br />
di Santo, Javier - XXXXXX<br />
Dvorkin, Camila - XXXXX</div></p>
</section>

<section class="slide level2">

<p><a href="https://github.com/FdelMazo/7531-TDL"><img data-src="lisp.png" /></a></p>
</section>
<section>
<section id="historia" class="title-slide slide level1">
<h1>Historia</h1>
<p><a href="https://campus.hesge.ch/Daehne/2004-2005/Langages/Lisp.htm">Early LISP History (1956 - 1959) ~ Herbert Stoyan</a></p>
<p><a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">History of Lisp ~ John McCarthy</a></p>
<p><a href="http://www.paulgraham.com/icad.html">Revenge of the Nerds ~ Paul Graham</a></p>
<p><a href="https://youtu.be/hGY3uBHVVr4">Lets LISP like it’s 1959</a> // <a href="https://lwn.net/Articles/778550/">LISP and the foundations of computing</a></p>
</section>
<section id="section" class="slide level2">
<h2></h2>
<p><img data-src="mccarthy.png" /></p>
<blockquote>
<p>“Programming is the problem of describing procedures or algorithms to an electronic calculator.”</p>
</blockquote>
<p>~ John McCarthy, The Programming Problem</p>
</section>
<section id="por-qué-nace-lisp" class="slide level2">
<h2>¿Por qué nace LISP?</h2>
<ul>
<li><p>Un lenguaje de programación para Inteligencia Artificial Simbólica.</p>
<ul>
<li>¿Cómo se representa el conocimiento humano en términos computacionales?</li>
</ul></li>
<li><p>McCarthy busca un lenguaje: Explicito, universal, conciso.</p></li>
<li><p>Una respuesta al modelo secuencial (la máquina de Turing) y al paradigma imperativo (FORTRAN).</p></li>
</ul>
</section>
<section id="cómo-nace-lisp" class="slide level2">
<h2>¿Cómo nace LISP?</h2>
<p><strong>Idea</strong></p>
<ul>
<li><p>En los 50 se empiezan a desarrollar los primeros lenguajes de alto nivel (FLOW-MATIC, FORTRAN)</p></li>
<li><p>En 1956, en una conferencia de AI, McCarthy se inspira para comenzar a diseñar LISP (LISt Proccessing) usando:</p>
<ul>
<li><p>Las ideas de procesamiento de listas y recursión de IPL-II</p></li>
<li><p>El alto nivel de FORTRAN (1957) y su expresión algebraica.</p></li>
<li><p>La notación del cálculo Lambda de Alonzo Church.</p></li>
</ul></li>
</ul>
</section>
<section id="cómo-nace-lisp-1" class="slide level2">
<h2>¿Cómo nace LISP?</h2>
<p><strong>Definición</strong></p>
<ul>
<li><p>1958: “An Algebraic Language for the Manipulation of Symbolic Expression”</p>
<ul>
<li><p>Primer diseño (incompleto) de LISP.</p></li>
<li><p>Comienzos de la programación funcional.</p></li>
</ul></li>
<li><p>1960: “Recursive Functions of Symbolic Expressionsand Their Computation by Machine, Part I”</p>
<ul>
<li><p>Especificación completa de LISP, un lenguaje <em>teórico</em>, que no estaba pensado para ser implementado.</p></li>
<li><p>Solución más comprensible a la máquina de Turing.</p></li>
<li><p>Para demostrar que es Turing-Completo, define una “función universal de LISP”, que luego llegaría a ser <code>eval</code>.</p></li>
</ul></li>
</ul>
</section>
<section id="cómo-nace-lisp-2" class="slide level2">
<h2>¿Cómo nace LISP?</h2>
<p><strong>Implementación</strong></p>
<ul>
<li><p>1960: Steve Russell, un alumno de McCarthy, decide probar e implementar en código máquina <code>eval</code></p>
<ul>
<li>Primer interprete de LISP, para la IBM 704.</li>
</ul></li>
<li><p>1962: Tim Hart y Mike Levin hacen el primer compilador de LISP.</p>
<ul>
<li><p>Lo más cercano al LISP que conocemos hoy en día.</p></li>
<li><p>Funciones compiladas e interpretadas pueden ser intercambiadas libremente.</p></li>
</ul></li>
</ul>
</section></section>
<section>
<section id="caracteristicas-del-lenguaje" class="title-slide slide level1">
<h1>Caracteristicas del Lenguaje</h1>

</section>
<section id="pionero" class="slide level2">
<h2>Pionero</h2>
<p><a href="http://www.paulgraham.com/diff.html">What Made Lisp Different ~ Paul Graham</a></p>
<p><a href="https://www.informit.com/articles/article.aspx?p=1671639">Influential Programming Languages, Lisp ~ David Chisnall</a></p>
<ul>
<li><p><strong>if-then-else</strong>: Las expresiones condicionales fueron definidas en el paper de 1960, con <code>cond</code>.</p></li>
<li><p><strong>Funciones</strong>: Las funciones como ciudadanos de primera clase</p></li>
<li><p><strong>Recursión</strong>: Ya existía matemáticamente, pero nunca en un lenguaje de programación</p></li>
<li><p><strong>Garbarge Collection</strong>: Con un diseño primitivo (no era concurrente), LISP fue el primer lenguaje en utilizar garbage collection automático.</p></li>
<li><p><strong>Tipado dinámico</strong>: No hay que explicitar si algo es un átomo o una lista.</p></li>
<li><p><strong>Interactividad</strong>: Gracias al interprete REPL se tiene feedback inmediato y se puede programar desde abajo para arriba, compilando incrementalmente.</p></li>
<li><p><strong>Map y Reduce</strong>: LISP fue el primer lenguaje en implementar dos funciones muy importantes en la programación funcional.</p></li>
</ul>
</section></section>
<section>
<section id="sintaxis" class="title-slide slide level1">
<h1>Sintaxis</h1>
<p><a href="http://web.cse.ohio-state.edu/~rountev.1/6341/pdf/Manual.pdf">LISP 1.5 Programmer’s Manual</a></p>
<p><a href="http://clhs.lisp.se/Front/index.htm">Common Lisp HyperSpec</a></p>
<p><a href="https://learnxinyminutes.com/docs/common-lisp/">Learn X in Y minutes, Where X=Common Lisp</a></p>
</section>
<section id="expresiones---átomos-y-listas" class="slide level2">
<h2>Expresiones -&gt; átomos y listas</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">;; Todo en LISP se compone de symbolic expressions</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dv">1</span> <span class="co">; Una s-expression puede ser un átomo -&gt; irreducible</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="co">; Una s-expression puede ser una lista -&gt; partible</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">;; Las s-expressions evaluan a valores</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="dv">2</span> <span class="co">; evalua a 2</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>(<span class="op">+</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; evalua a 5</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>(<span class="op">+</span> (<span class="op">+</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="dv">2</span>) <span class="co">; (+ 2 3) evalua a 5 -&gt; todo evalua a 7</span></span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co">;; Acá comienza la dualidad entre código (la lista) y data (el átomo)</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">;; Ambos son S-expressions</span></span></code></pre></div>
</section>
<section id="code-data---eval-quote" class="slide level2">
<h2>Code &amp; Data -&gt; <code>eval</code>, <code>quote</code></h2>
<p><a href="https://youtu.be/dw-y3vNDRWk">Code vs Data (Metaprogramming) ~ Computerphile</a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">;; El operador quote toma una s-expression y devuelve el código</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>) <span class="co">; evalua a 2</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>(<span class="kw">quote</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a (+ 1 1)</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>(&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; quote se abrevia a &#39;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co">;; El operador eval toma una s-expresion y devuelve su valor</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>(<span class="kw">eval</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a 2</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>(<span class="kw">eval</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a 2</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>(<span class="kw">eval</span> &#39;&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a (+ 1 1)</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co">;; 1 + 1 es 2</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co">;; &quot;1 + 1&quot; es el código 1 + 1</span></span></code></pre></div>
<p>Puedo hacer un programa entero, ponerle un <code>'</code> adelante, y estoy tratando con el <strong>código</strong> de mi programa.</p>
</section>
<section id="chequeando-valores---atom-listp" class="slide level2">
<h2>Chequeando Valores -&gt; <code>atom</code>, <code>listp</code></h2>
<p>¿Es código o data?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">;; atom devuelve si algo es un átomo o no</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>(<span class="kw">atom</span> <span class="dv">1</span>) <span class="co">; True (el valor de la expresion 1 es un átomo)</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>(<span class="kw">atom</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; True (el valor de la expresion (+ 1 2) es un átomo)</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>(<span class="kw">atom</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; Nil (la expresion (+ 1 2) es una lista)</span></span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co">;; listp devuelve si algo es una lista o no</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>(<span class="kw">listp</span> <span class="dv">1</span>) <span class="co">; Nil (1 no es una lista)</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>(<span class="kw">listp</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; Nil (la expresion evalua a 3, no es una lista)</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>(<span class="kw">listp</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; True (estoy hablando del código de la expresion, la lista)</span></span></code></pre></div>
</section>
<section id="procesar-listas---car-cdr-cons-y-list" class="slide level2">
<h2>Procesar listas -&gt; <code>car</code>, <code>cdr</code>, <code>cons</code> y <code>list</code></h2>
<ul>
<li><p>Las listas en LISP son listas enlazadas</p></li>
<li><p>Los “nodos” (dato y prox) se llaman <strong>cons cells</strong></p>
<ul>
<li><p>El dato actual es el <strong>car</strong></p></li>
<li><p>El resto es otra lista, el <strong>cdr</strong></p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">;; car recibe una lista y devuelve su primer elemento</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>(<span class="kw">car</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; explota, no recibio una lista</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>(<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; devuelve +</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">;; cdr recibe una lista y devuelve el resto (todo menos el primer elemento)</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>(<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; devuelve (1 2)</span></span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">;; cons crea un cons de un valor seguido de una lista</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">;; AKA agrega un valor al principio de la lista</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>(<span class="kw">cons</span> &#39;<span class="dv">1</span> &#39;(<span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; devuelve (1 2 3)</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>(<span class="kw">cons</span> &#39;+ &#39;(<span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; devuelve (+ 2 3)</span></span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a><span class="co">;; list compone una lista de sus argumentos</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>(<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; devuelve (1 2 3)</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>(<span class="kw">list</span> &#39;+ <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; devuelve (+ 2 3)</span></span>
<span id="cb4-16"><a href="#cb4-16"></a><span class="co">;; si tan solo hubiese una manera de ejecutar esta expresion!</span></span></code></pre></div>
</section>
<section id="procesar-una-s-expression---programming-bottom-up" class="slide level2">
<h2>Procesar una s-expression -&gt; Programming Bottom Up</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">;; Partimos de la expresion (+ 1 2)</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">;; La convertimos en el código de la expresion</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">;; Sacamos su operador -&gt; el +</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>(<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))</span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">;; Sacamos los operandos -&gt; el (1 2)</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>(<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))</span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">;; Empaquetamos esto nuevamente -&gt; (+ 1 2)</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>(<span class="kw">cons</span> (<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) (<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)))</span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">;; Evaluamos la expresion</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>(<span class="kw">eval</span> (<span class="kw">cons</span> (<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) (<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))))</span></code></pre></div>
</section></section>
<section>
<section id="desglosando-eval" class="title-slide slide level1">
<h1>Desglosando <code>eval</code></h1>
<p><a href="http://www.paulgraham.com/rootsoflisp.html">The Roots of LISP ~ Paul Graham</a></p>
<p><a href="https://youtu.be/OyfBQmvr2Hc">The Most Beautiful Program Ever Written ~ William Byrd</a></p>
<ul>
<li><p>La magía de LISP es el <strong>read–eval–print loop</strong>: un entorno donde se toma lo escrito por el programador, se lee, se evalua, se imprime, y luego se vuelve a pedir input</p></li>
<li><p>Este self-interpreter es un <strong>evaluador meta-circular</strong>, esta escrito en LISP y puede evaluar código de LISP.</p></li>
<li><p>¿Cómo? Gracias a la función <code>eval</code>, definida por McCarthy en base a 7 operadores que toma como axiomas: <code>quote</code>, <code>atom</code>, <code>eq</code>, <code>car</code>, <code>cdr</code>, <code>cons</code> y <code>cond</code></p></li>
</ul>
</section>
<section id="section-1" class="slide level2">
<h2></h2>
<blockquote>
<p>That was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.</p>
</blockquote>
<p>~ Alan Kay, <a href="https://queue.acm.org/detail.cfm?id=1039523">A Conversation with Alan Kay</a></p>
<p><img data-src="eval.png" /></p>
</section>
<section id="section-2" class="slide level2">
<h2></h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">;; Anotaciones sobre el código de Paul Graham en Roots of Lisp</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co">; The Lisp defined in McCarthy&#39;s 1960 paper, translated into Common Lisp.</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">; eval recibe una expresion `e` y una lista de argumentos `a` -&gt; El &quot;entorno&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">; Básicamente, recibe todo el scope donde estoy parado</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>(<span class="kw">defun</span><span class="fu"> eval </span>(e a)</span>
<span id="cb6-7"><a href="#cb6-7"></a>  <span class="co">; Es todo un if grande de 4 condiciones que chequean el tipo de la expresion</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>  (<span class="kw">cond</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="co">; Si es un atomo -&gt; Devuelvo su valor en el entorno</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    ((<span class="kw">atom</span> e) (<span class="kw">assoc</span> e a))</span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="co">; Si no es un atomo tiene que ser una lista</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="co">; Si es una lista del tipo (atomo...resto) -&gt; Es una función!</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>    <span class="co">; (car e) es el operador</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>    <span class="co">; (cadr e) es (car (cdr e)) que es el primero de los argumentos</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>    ((<span class="kw">atom</span> (<span class="kw">car</span> e))</span>
<span id="cb6-16"><a href="#cb6-16"></a>     <span class="co">; Si Es una funcion, ¿que funcion es?</span></span>
<span id="cb6-17"><a href="#cb6-17"></a>     (<span class="kw">cond</span></span>
<span id="cb6-18"><a href="#cb6-18"></a>       <span class="co">; Si es quote, solo devuelvo los argumentos de la funcion</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;quote) (<span class="kw">cadr</span> e))</span>
<span id="cb6-20"><a href="#cb6-20"></a>       <span class="co">; Para el resto de los axiomas, llamo a esa funcion contra los argumentos</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>       <span class="co">; Como quiero llamar a la operacion contra los valores de los argumentos, llamo a eval</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;atom)  (<span class="kw">atom</span>   (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)))</span>
<span id="cb6-23"><a href="#cb6-23"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;eq)    (<span class="kw">eq</span>     (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)</span>
<span id="cb6-24"><a href="#cb6-24"></a>                                    (<span class="kw">eval</span> (<span class="kw">caddr</span> e) a)))</span>
<span id="cb6-25"><a href="#cb6-25"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;car)   (<span class="kw">car</span>    (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)))</span>
<span id="cb6-26"><a href="#cb6-26"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;cdr)   (<span class="kw">cdr</span>    (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)))</span>
<span id="cb6-27"><a href="#cb6-27"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;cons)  (<span class="kw">cons</span>   (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)</span>
<span id="cb6-28"><a href="#cb6-28"></a>                                    (<span class="kw">eval</span> (<span class="kw">caddr</span> e) a)))</span>
<span id="cb6-29"><a href="#cb6-29"></a>       <span class="co">; cond tiene que evaluar recursivamente todas las condiciones, hasta encontrar el primer true</span></span>
<span id="cb6-30"><a href="#cb6-30"></a>       <span class="co">; para eso, se define una funcion auxiliar, `evcon` que recorre la lista de parametros y los evalua</span></span>
<span id="cb6-31"><a href="#cb6-31"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;cond)  (evcon (<span class="kw">cdr</span> e) a))</span>
<span id="cb6-32"><a href="#cb6-32"></a>       <span class="co">; el caso final es recibir una funcion definida por el usuario</span></span>
<span id="cb6-33"><a href="#cb6-33"></a>       (&#39;t (<span class="kw">eval</span> (<span class="kw">cons</span> (<span class="kw">assoc</span> (<span class="kw">car</span> e) a)</span>
<span id="cb6-34"><a href="#cb6-34"></a>                        (<span class="kw">cdr</span> e))</span>
<span id="cb6-35"><a href="#cb6-35"></a>                  a))))</span>
<span id="cb6-36"><a href="#cb6-36"></a>    <span class="co">; Si no es un atomo ni una lista que comienza por un atomo, entonces es una lista que comienza por otra cosa</span></span>
<span id="cb6-37"><a href="#cb6-37"></a>    <span class="co">; Si es una lista que comienza con label, evaluo la funcion a la que refiere</span></span>
<span id="cb6-38"><a href="#cb6-38"></a>    ((<span class="kw">eq</span> (<span class="kw">caar</span> e) &#39;label)</span>
<span id="cb6-39"><a href="#cb6-39"></a>     (<span class="kw">eval</span> (<span class="kw">cons</span> (<span class="kw">caddar</span> e) (<span class="kw">cdr</span> e))</span>
<span id="cb6-40"><a href="#cb6-40"></a>            (<span class="kw">cons</span> (<span class="kw">list</span> (<span class="kw">cadar</span> e) (<span class="kw">car</span> e)) a)))</span>
<span id="cb6-41"><a href="#cb6-41"></a>    <span class="co">; Si es una lista que comienza con lambda, evaluo sus parametros</span></span>
<span id="cb6-42"><a href="#cb6-42"></a>    ((<span class="kw">eq</span> (<span class="kw">caar</span> e) &#39;lambda)</span>
<span id="cb6-43"><a href="#cb6-43"></a>     (<span class="kw">eval</span> (<span class="kw">caddar</span> e)</span>
<span id="cb6-44"><a href="#cb6-44"></a>            (<span class="kw">append</span> (pair (<span class="kw">cadar</span> e) (evlis  (<span class="kw">cdr</span> e) a))</span>
<span id="cb6-45"><a href="#cb6-45"></a>                     a)))))</span></code></pre></div>
</section></section>
<section id="preguntas" class="title-slide slide level1">
<h1>Preguntas</h1>
<p>¿? ¿? ¿?</p>
</section>
    </div>
  </div>

  <script src="./reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: './reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: './reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
