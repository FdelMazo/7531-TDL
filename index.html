<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>(Common) LISP</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./reveal.js/css/theme/simple.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? './reveal.js/css/print/pdf.css' : './reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="./reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">(Common) LISP</h1>
  <p class="author"><div class="line-block">del Mazo, Federico - 100029<br />
Di Santo, Javier - 101696<br />
Dvorkin, Camila - 101109<br />
Secchi, Anita - 99131</div></p>
</section>

<section class="slide level2">

<p><a href="https://github.com/FdelMazo/7531-TDL"><img data-src="img/byte.png" /></a></p>
</section>
<section><section id="historia" class="title-slide slide level1"><h1>Historia</h1></section><section id="section" class="slide level2">
<h2></h2>
<p><img data-src="img/mccarthy.png" /></p>
<blockquote>
<p>“Programming is the problem of describing procedures or algorithms to an electronic calculator.”</p>
</blockquote>
<p>~ John McCarthy, The Programming Problem</p>
</section><section id="por-qué-nace-lisp" class="slide level2">
<h2>¿Por qué nace LISP?</h2>
<ul>
<li><p>Un lenguaje de programación para Inteligencia Artificial Simbólica.</p>
<ul>
<li>¿Cómo se representa el conocimiento humano en términos computacionales?</li>
</ul></li>
<li><p>McCarthy busca un lenguaje: Explicito, universal, conciso.</p></li>
<li><p>Una respuesta al modelo secuencial (la máquina de Turing) y al paradigma imperativo (FORTRAN).</p></li>
</ul>
</section><section id="cómo-nace-lisp" class="slide level2">
<h2>¿Cómo nace LISP?</h2>
<p><strong>Idea</strong></p>
<ul>
<li><p>En los 50 se empiezan a desarrollar los primeros lenguajes de alto nivel (FLOW-MATIC, FORTRAN)</p></li>
<li><p>En 1956, en una conferencia de AI, McCarthy se inspira para comenzar a diseñar LISP (LISt Proccessing) usando:</p>
<ul>
<li><p>Las ideas de procesamiento de listas y recursión de IPL-II</p></li>
<li><p>El alto nivel de FORTRAN (1957) y su expresión algebraica.</p></li>
<li><p>La notación del cálculo Lambda de Alonzo Church.</p></li>
</ul></li>
</ul>
</section><section id="cálculo-lambda" class="slide level2">
<h2>Cálculo Lambda</h2>
<p><strong>λx . x+x</strong></p>
<p><a href="https://youtu.be/eis11j_iGMs">Lambda calculus ~ Computerphile</a></p>
<p><a href="https://www.jtolio.com/2017/03/whiteboard-problems-in-pure-lambda-calculus/">Whiteboard problems in pure Lambda calculus</a></p>
<p><a href="http://www.flownet.com/ron/lambda-calculus.html">The Awesome Power of Theory, Explorations in the untyped lambda calculus ~ Ron Garret</a></p>
<p><a href="https://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/church.pdf">“An Unsolvable Problem Of Elementary Number Theory” (1936) ~ Alonzo Church</a></p>
<p><a href="http://www.csc.villanova.edu/~beck/csc8310/BackusFP.pdf">“Can Programming Be Liberated from the von Neumann Style?” (1977) ~ John Backus</a></p>
<ul>
<li><p>No hay estado interno</p></li>
<li><p>Solo tiene:</p>
<ul>
<li><p>Identificadores (variables)</p></li>
<li><p>Expresiones lambda (construcción de funciones)</p></li>
<li><p>Aplicación de funciones</p></li>
</ul></li>
<li><p>Church–Turing thesis: la notación Lambda es formalmente equivalente a una máquina de Turing</p></li>
</ul>
</section><section id="cómo-nace-lisp-1" class="slide level2">
<h2>¿Cómo nace LISP?</h2>
<p><strong>Definición</strong></p>
<ul>
<li><p><a href="http://www.softwarepreservation.org/projects/LISP/MIT/AIM-001.pdf">“An Algebraic Language for the Manipulation of Symbolic Expression” (1958) ~ John McCarthy</a></p>
<ul>
<li><p>Primer diseño (incompleto) de LISP.</p></li>
<li><p>Comienzos de la programación funcional.</p></li>
</ul></li>
<li><p><a href="http://www-formal.stanford.edu/jmc/recursive.pdf">“Recursive Functions of Symbolic Expressionsand Their Computation by Machine, Part I” (1960) ~ John McCarthy</a></p>
<ul>
<li><p>Especificación completa de LISP, un lenguaje <em>teórico</em>, que no estaba pensado para ser implementado.</p></li>
<li><p>Solución más comprensible a la máquina de Turing.</p></li>
<li><p>Para demostrar que es Turing-Completo, define una “función universal de LISP”, que luego llegaría a ser <code>eval</code>.</p></li>
</ul></li>
</ul>
</section><section id="cómo-nace-lisp-2" class="slide level2">
<h2>¿Cómo nace LISP?</h2>
<p><strong>Implementación</strong></p>
<ul>
<li><p>1960: Steve Russell, un alumno de McCarthy, decide probar e implementar en código máquina <code>eval</code></p>
<ul>
<li>Primer interprete de LISP, para la IBM 704.</li>
</ul></li>
<li><p>1962: Tim Hart y Mike Levin hacen el primer compilador de LISP.</p>
<ul>
<li><p>Lo más cercano al LISP que conocemos hoy en día.</p></li>
<li><p>Funciones compiladas e interpretadas pueden ser intercambiadas libremente.</p></li>
</ul></li>
</ul>
</section><section id="pionero" class="slide level2">
<h2>Pionero</h2>
<p><a href="http://www.paulgraham.com/diff.html">What Made Lisp Different ~ Paul Graham</a></p>
<p><a href="https://www.informit.com/articles/article.aspx?p=1671639">Influential Programming Languages, Lisp ~ David Chisnall</a></p>
<ul>
<li><p><strong>if then else</strong></p></li>
<li><p><strong>Funciones</strong> como objetos de primera clase</p></li>
<li><p><strong>Recursión</strong></p></li>
<li><p>Todas las variables son <strong>punteros</strong></p></li>
<li><p><strong>Garbarge Collection automático</strong></p></li>
<li><p><strong>Tipado dinámico</strong></p></li>
<li><p><strong>Interactividad</strong> gracias al interprete <strong>REPL</strong></p></li>
<li><p>Programas compuestos por <strong>expresiones</strong></p></li>
<li><p>El lenguaje completo está siempre disponible</p></li>
<li><p><strong>Map y Reduce</strong></p></li>
</ul>
</section></section>
<section><section id="sintaxis" class="title-slide slide level1"><h1>Sintaxis</h1></section><section id="expresiones---átomos-y-listas" class="slide level2">
<h2>Expresiones -&gt; átomos y listas</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">;; Todo en LISP se compone de symbolic expressions</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="dv">1</span> <span class="co">; Una s-expression puede ser un átomo -&gt; irreducible</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="co">; Una s-expression puede ser una lista -&gt; partible</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="co">;; Las s-expressions evaluan a valores</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="dv">2</span> <span class="co">; evalua a 2</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">(<span class="op">+</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; evalua a 5</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">(<span class="op">+</span> (<span class="op">+</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="dv">2</span>) <span class="co">; (+ 2 3) evalua a 5 -&gt; todo evalua a 7</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="co">;; Acá comienza la dualidad entre código (la lista) y data (el átomo)</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="co">;; Ambos son S-expressions</span></a></code></pre></div>
</section><section id="code-data---eval-quote" class="slide level2">
<h2>Code &amp; Data -&gt; <code>eval</code>, <code>quote</code></h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">;; El operador quote toma una s-expression y devuelve el código</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>) <span class="co">; evalua a 2</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">(<span class="kw">quote</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a (+ 1 1)</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">(&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; quote se abrevia a &#39;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co">;; El operador eval toma una s-expresion y devuelve su valor</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">(<span class="kw">eval</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a 2</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">(<span class="kw">eval</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a 2</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">(<span class="kw">eval</span> &#39;&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a (+ 1 1)</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="co">;; 1 + 1 es 2</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="co">;; &quot;1 + 1&quot; es el código 1 + 1</span></a></code></pre></div>
<p>Puedo hacer un programa entero, ponerle un <code>'</code> adelante, y estoy tratando con el <strong>código</strong> de mi programa.</p>
</section><section id="chequeando-valores---atom-listp" class="slide level2">
<h2>Chequeando Valores -&gt; <code>atom</code>, <code>listp</code></h2>
<p>¿Es código o data?</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">;; atom devuelve si algo es un átomo o no</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">(<span class="kw">atom</span> <span class="dv">1</span>) <span class="co">; True (el valor de la expresion 1 es un átomo)</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">(<span class="kw">atom</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; True (el valor de la expresion (+ 1 2) es un átomo)</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">(<span class="kw">atom</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; Nil (la expresion (+ 1 2) es una lista)</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co">;; listp devuelve si algo es una lista o no</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">(<span class="kw">listp</span> <span class="dv">1</span>) <span class="co">; Nil (1 no es una lista)</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">(<span class="kw">listp</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; Nil (la expresion evalua a 3, no es una lista)</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">(<span class="kw">listp</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; True (estoy hablando del código de la expresion, la lista)</span></a></code></pre></div>
</section><section id="procesar-listas---car-cdr-cons-y-list" class="slide level2">
<h2>Procesar listas -&gt; <code>car</code>, <code>cdr</code>, <code>cons</code> y <code>list</code></h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">;; car recibe una lista y devuelve su primer elemento</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">(<span class="kw">car</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; explota, no recibio una lista</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">(<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; devuelve +</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">;; cdr recibe una lista y devuelve el resto (todo menos el primer elemento)</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">(<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; devuelve (1 2)</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="co">;; cons crea un cons de un valor seguido de una lista</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="co">;; AKA agrega un valor al principio de la lista</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">(<span class="kw">cons</span> &#39;<span class="dv">1</span> &#39;(<span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; devuelve (1 2 3)</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">(<span class="kw">cons</span> &#39;+ &#39;(<span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; devuelve (+ 2 3)</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12"></a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="co">;; list compone una lista de sus argumentos</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">(<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; devuelve (1 2 3)</span></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">(<span class="kw">list</span> &#39;+ <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; devuelve (+ 2 3)</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16"><span class="co">;; si tan solo hubiese una manera de ejecutar esta expresion!</span></a></code></pre></div>
</section><section id="procesar-una-s-expression---programming-bottom-up" class="slide level2">
<h2>Procesar una s-expression -&gt; Programming Bottom Up</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">;; Partimos de la expresion (+ 1 2)</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="co">;; La convertimos en el código de la expresion</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="co">;; Sacamos su operador -&gt; el +</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">(<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="co">;; Sacamos los operandos -&gt; el (1 2)</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">(<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="co">;; Empaquetamos esto nuevamente -&gt; (+ 1 2)</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">(<span class="kw">cons</span> (<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) (<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)))</a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="co">;; Evaluamos la expresion</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">(<span class="kw">eval</span> (<span class="kw">cons</span> (<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) (<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))))</a></code></pre></div>
</section></section>
<section><section id="ejemplo-de-tda-tablas-de-hash" class="title-slide slide level1"><h1>Ejemplo de TDA: Tablas de hash</h1></section><section id="crear-una-tabla-de-hash-en-common-lisp" class="slide level2">
<h2>Crear una tabla de hash en Common Lisp</h2>
<ul>
<li>función <code>make-hash-table</code></li>
<li>No requiere ningún argumento, pero el opcional más usado es <code>:TEST</code> (testear claves iguales)</li>
</ul>
<p>Ejemplo:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb6-1" data-line-number="1">(<span class="kw">defvar</span><span class="fu"> tabla</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">(<span class="kw">setq</span> tabla (<span class="kw">make-hash-table</span> <span class="bu">:test</span> &#39;equal))</a></code></pre></div>
</section><section id="agregar-un-elemento-a-la-tabla" class="slide level2">
<h2>Agregar un elemento a la tabla</h2>
<ul>
<li>función <code>gethash</code> en conjunto con la función <code>setf</code></li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="op">*</span> (<span class="kw">setf</span> (<span class="kw">gethash</span> <span class="st">&quot;clave1&quot;</span> tabla) <span class="dv">3</span>) <span class="co">; gethash recibe dos argumentos: la clave y el hash</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="dv">3</span></a></code></pre></div>
</section><section id="obtener-un-valor" class="slide level2">
<h2>Obtener un valor</h2>
<ul>
<li>función <code>gethash</code> toma dos argumentos obligatorios: una clave y una tabla de hash</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="op">*</span> (<span class="kw">setf</span> (<span class="kw">gethash</span> <span class="st">&quot;clave1&quot;</span> tabla) <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="dv">3</span></a></code></pre></div>
</section><section id="borrar-de-la-tabla-de-hash" class="slide level2">
<h2>Borrar de la tabla de hash</h2>
<ul>
<li>función <code>remhash</code> para eliminar el par clave-valor</li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="op">*</span> (<span class="kw">remhash</span> <span class="st">&quot;clave1&quot;</span> tabla) <span class="co">; elimino el par: &quot;clave&quot;-3</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">T</a></code></pre></div>
</section><section id="contar-entradas" class="slide level2">
<h2>Contar entradas</h2>
<ul>
<li>función <code>hash-table-count</code></li>
</ul>
<div class="sourceCode" id="cb10"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="op">*</span> (<span class="kw">hash-table-count</span> tabla)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="dv">3</span> <span class="co">; 3 elementos en mi hash.</span></a></code></pre></div>
</section><section id="el-tamaño-del-hash" class="slide level2">
<h2>El tamaño del hash</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="op">*</span> (<span class="kw">setq</span> tabla (<span class="kw">make-hash-table</span> <span class="bu">:test</span> &#39;equal))</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">#&lt;HASH-TABLE :TEST EQUAL :COUNT <span class="dv">0</span> {10058B8553}<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="op">*</span>(<span class="kw">hash-table-size</span> tabla)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="dv">16</span> <span class="co">; por default</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="op">*</span>(<span class="kw">hash-table-rehash-size</span> tabla)</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="fl">1.5</span> <span class="co">; indica que la tabla se agrandará en un 50% cada vez que necesite crecer.</span></a></code></pre></div>
<ul>
<li>Ejemplo: agregar un total de un millón* de pares clave-valor al hash y ver como se redimensiona</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="op">*</span> (<span class="kw">time</span> (<span class="kw">dotimes</span> (n <span class="dv">1000000</span>) (<span class="kw">setf</span> (<span class="kw">gethash</span> n tabla) n))) <span class="co">; le tomo el tiempo que tarda</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">Evaluation took:</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="fl">0.162</span> seconds of <span class="kw">real</span> <span class="kw">time</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="fl">0.161954</span> seconds of total run <span class="kw">time</span> (<span class="fl">0.137696</span> <span class="kw">user</span>, <span class="fl">0.024258</span> <span class="kw">system</span>)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  [ Run times consist of <span class="fl">0.015</span> seconds GC <span class="kw">time</span>, <span class="kw">and</span> <span class="fl">0.147</span> seconds non-GC <span class="kw">time</span>. ]</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">  <span class="fl">100.00</span>% CPU</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  <span class="dv">355</span>,<span class="dv">501</span>,<span class="dv">132</span> processor cycles</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  <span class="dv">83</span>,<span class="dv">836</span>,<span class="dv">896</span> bytes consed</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">NIL</a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="op">*</span> (<span class="kw">hash-table-count</span> tabla)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="dv">1000000</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"><span class="op">*</span> (<span class="kw">hash-table-size</span> tabla)</a>
<a class="sourceLine" id="cb12-13" data-line-number="13"><span class="dv">1048576</span></a></code></pre></div>
<p>*<em>Se eligió un millón para resaltar los tiempos que tardan</em></p>
<p>(Ver más sobre esto en informe.md)</p>
</section><section id="fun-stuff-e-iteradores-del-hash" class="slide level2">
<h2>Fun stuff e iteradores del hash</h2>
<ul>
<li><code>maphash</code>: itera sobre todas las claves de la tabla. Devuelve siempre <code>NIL</code>.</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="op">*</span> (<span class="kw">defun</span><span class="fu"> imprimir-entrada </span>(clave valor) (<span class="kw">format</span> <span class="kw">t</span> <span class="st">&quot;El valor asociado a la clave ~S es ~S~%&quot;</span> clave valor)) <span class="co">; partimos de un hash con 3 claves</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">IMPRIMIR-ENTRADA</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="op">*</span> (<span class="kw">maphash</span> #&#39;imprimir-entrada tabla)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">El valor asociado a la clave <span class="st">&quot;clave1&quot;</span> es <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">El valor asociado a la clave <span class="st">&quot;clave2&quot;</span> es <span class="dv">2</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">El valor asociado a la clave <span class="st">&quot;clave3&quot;</span> es <span class="dv">3</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">NIL</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="op">*</span></a></code></pre></div>
<ul>
<li><code>with-hash-table-iterator</code>: es una macro que convierte el primer argumento en un iterador que en cada invocación devuelve un booleano generalizado que es <code>true</code> si alguna entrada es devuelta, la clave, y el valor. Si no encuentra más claves, devuelve <code>NIL</code></li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="op">*</span> (<span class="kw">with-hash-table-iterator</span> (iterador tabla)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    (<span class="kw">loop</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">        (<span class="kw">multiple-value-bind</span> (entrada clave valor)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">            (iterador)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">        (<span class="kw">if</span> entrada</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">            (imprimir-entrada clave valor)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">            (<span class="kw">return</span>)))))</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">El valor asociado a la clave <span class="st">&quot;clave1&quot;</span> es <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">El valor asociado a la clave <span class="st">&quot;clave2&quot;</span> es <span class="dv">2</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">El valor asociado a la clave <span class="st">&quot;clave3&quot;</span> es <span class="dv">3</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">NIL</a></code></pre></div>
<p>Otra opción para it</p>
<ul>
<li><code>loop</code>: es otra opción para iterar</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb15-1" data-line-number="1">  <span class="op">*</span> (<span class="kw">loop</span> for clave being <span class="kw">the</span> hash-keys of tabla <span class="kw">do</span> (<span class="kw">print</span> clave))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="st">&quot;clave1&quot;</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="st">&quot;clave2&quot;</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="st">&quot;clave3&quot;</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">NIL</a></code></pre></div>
<p>HASH TABLE: http://cl-cookbook.sourceforge.net/hashes.html - https://www.tutorialspoint.com/lisp/lisp_hash_table.htm</p>
</section></section>
<section><section id="fractales-en-common-lisp" class="title-slide slide level1"><h1>Fractales, en Common LISP</h1></section></section>
<section><section id="metaprogramming" class="title-slide slide level1"><h1>Metaprogramming</h1></section><section id="orientado-a-expresiones" class="slide level2">
<h2>Orientado a expresiones</h2>
<p><a href="https://en.wikipedia.org/wiki/Expression-oriented_programming_language">Expression-oriented programming language</a></p>
<p><a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html">Why Racket? Why Lisp? ~ Beautiful Racket</a></p>
<ul>
<li><p>La mayoria de los los lenguajes distinguen entre <code>expresiones</code> y <code>sentencias</code> (statements)</p>
<ul>
<li><p>Expresión: frases que son evaluadas</p>
<ul>
<li><p>Siempre producen un valor</p></li>
<li><p>Suelen no tener efectos secundarios</p></li>
</ul></li>
<li><p>Sentencias: frases que marcan una acción</p>
<ul>
<li><p>No retornan valores</p></li>
<li><p>Se ejecutan solamente por sus efectos secundarios</p></li>
</ul></li>
</ul></li>
<li><p>En LISP, todo es una expresiónn</p>
<ul>
<li><p>Facil de testear</p></li>
<li><p>Código mas expresivo</p></li>
<li><p>Anidar expresiones de manera concisa</p></li>
</ul></li>
<li><p>Transparencia referencial: equals can be replaced by equals</p></li>
</ul>
</section><section id="symbolic-expression" class="slide level2">
<h2>Symbolic expression</h2>
<div class="container">
<div class="col">
<p><strong>atom</strong></p>
<p><img data-src="img/atom.png" /></p>
<p><code>x</code></p>
</div>
<div class="col">
<p><strong>construct cell</strong></p>
<p><img data-src="img/cons.png" /></p>
<p><code>(x . y)</code></p>
</div>
</div>
</section><section id="list" class="slide level2">
<h2>list</h2>
<p><img data-src="img/list.png" /></p>
<p><code>(x . (y . (z . NIL)))</code> === <code>(x y z)</code></p>
</section><section id="tree" class="slide level2">
<h2>tree</h2>
<p><img data-src="img/tree.png" /></p>
<p><code>(x y z)</code></p>
</section><section id="s-expressions" class="slide level2">
<h2>s-expressions</h2>
<p><img data-src="img/sexp.png" /></p>
<p><code>(* (+ 1 2) (- 5 3) )</code></p>
</section><section id="conclusión" class="slide level2">
<h2>Conclusión</h2>
<ul>
<li><p>¿Cómo se representá mi código escrito? <strong>árbol de s-expressions</strong></p></li>
<li><p>¿Cómo se representá mi programa compilado? <strong>árbol de sintaxis abstracta (AST)</strong></p></li>
</ul>
<p><strong>La representación interna de mi código es muy parecida a mi código escrito</strong></p>
</section><section id="homoiconicidad" class="slide level2">
<h2>Homoiconicidad</h2>
<p><a href="https://en.wikipedia.org/wiki/Symbolic_programming">Symbolic programming</a></p>
<p><a href="https://en.wikipedia.org/wiki/Homoiconicity">Homoiconicity</a></p>
<p><a href="https://wiki.c2.com/?HomoiconicExampleInManyProgrammingLanguages">Homoiconic Example In Many Programming Languages ~ WikiWikiWeb</a></p>
<ul>
<li><p>LISP es un lenguaje simbólico: El código es un ciudadano de primera clase</p></li>
<li><p>LISP es homoicónico: su representación interna se infiere leyendo el código</p></li>
<li><p>Toda expresión se puede interpretar de las dos maneras.</p>
<ul>
<li><p>Se interpreta como data usando <code>quote</code></p></li>
<li><p>Se interpreta como código usando <code>eval</code></p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb16"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb16-1" data-line-number="1">(<span class="kw">setf</span> b <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">b <span class="co">; =&gt; 3</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">(<span class="kw">setf</span> a &#39;(<span class="kw">setf</span> b <span class="dv">15</span>))</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">a <span class="co">; =&gt; (SETF B 15)</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">(<span class="kw">eval</span> a)</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">b    <span class="co">; =&gt; 15</span></a></code></pre></div>
</section><section id="extensibilidad-del-lenguaje" class="slide level2">
<h2>Extensibilidad del lenguaje</h2>
<p>En vez de crear un software para satisfacer todas las necesidades del usuario, podemos crear un software que sea extensible. Es decir, cambiar nuestro programa para que sea un lenguaje de programación, y usuarios avanzados pueden agregar funcionalidad extra si la necesitan.</p>
<p>Lisp es un muy buen lenguaje para crear software extensible porque el lenguaje mismo es extensible: <em>permite escribir código que genera código</em>. En particular las macros permiten extender el lenguaje, cambiar el orden de evaluación y hasta cambiar la sintaxis. Con otros lenguajes no tenemos esta libertad, y cualquier extensión cambio en la sintaxis debería ser implementado de forma oficial por los desarrolladores del lenguaje.</p>
<ul>
<li><p>Crear módulos completos para extender la funcionalidad del lenguaje:</p>
<ul>
<li>Common Lisp Object System [CLOS]: agrega un sistema de objetos a Lisp, completo con enlaces dinámicos múltiples y herencia múltiple. Provee las macros <code>defclass</code>, <code>defgeneric</code>, <code>defmethod</code>.</li>
<li>lparallel: agrega funcionalidad para la creación de hilos. Incluye comunicación entre hilos, promesas, implementaciones de <code>map</code>, <code>reduce</code>, <code>sort</code> y <code>remove</code> que corren de forma concurrente, y más.</li>
</ul></li>
<li><p>Crear lenguajes de dominio específico cambiando la sintaxis:</p>
<ul>
<li><code>CL-INTERPOL</code>: para interpolación de strings.</li>
<li><code>infix</code>: para escribir ecuaciones matemáticas en notación de infijo.</li>
</ul></li>
<li><p>¿Aún más? Racket, undialecto de Scheme y parte de la familia de Lisp, está orientado específicamente a crear lenguajes nuevos agregando funcionalidad para convertir código fuente en S-Expressions.</p></li>
<li><p>TODO: Comparar con otros lenguajesss</p></li>
</ul>
</section><section id="macros" class="slide level2">
<h2>Macros</h2>
<ul>
<li><p>Despues de la teoria, Volver a cl-aristid y al REPL. Expandir macros, compararlos con las versiones canonicas, mostrar los macros definidos, como se definen, como cambian la sintaxis</p></li>
<li><p>Esta seccion que sea bien teorica con codigo (pero poco codigo). Los ejemplos ejemplos van en sintaxis</p></li>
<li><p>En Lisp, una macro es una función que genera código de Lisp. La forma más sencilla de pensarlo sería como una transformación de código. Cuando se llama a una macro en el código:</p></li>
</ul>
<ol type="1">
<li>Se arma el código en base a la definición <code>defmacro</code> de la misma.</li>
<li>Se evalúa el nuevo código en el lugar de la llamada a la macro.</li>
</ol>
<p>A partir de esto, se pueden usar macros para simplificar y reutilizar código, o hasta manipular la sintaxis del lenguaje.</p>
<ul>
<li>Algunos operadores:
<ul>
<li><code>Backquote `</code>: Funciona similar a <code>quote</code>. (se explica antes?)</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb17"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb17-1" data-line-number="1">`(a, b, c)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="co">; equivalente a escribir</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">&#39;(a b c)</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">(<span class="kw">list</span> &#39;a &#39;b &#39;c)</a></code></pre></div>
<ul>
<li><code>Comma ,</code>: Combinado con <code>backquote</code> sirve para “activar y desactivar” el efecto de <code>backquote</code>. Es útil al escribir macros:</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb18-1" data-line-number="1">`(a ,b c ,d)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="co">; equivalente a escribir</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">(<span class="kw">list</span> &#39;a b &#39;c d)</a></code></pre></div>
<ul>
<li><code>Comma-at ,@</code>: Dada una expresión que resuelve una lista, se puede utilizar <code>,@</code> para reemplazar esta lista por la secuencia de sus mismos elementos (elimina el paréntesis):</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb19-1" data-line-number="1">`(a b c)    -&gt;  (A (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) C)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">`(a ,@b c)  -&gt;  (A <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> C)</a></code></pre></div>
<ul>
<li><code>(nil! x)</code>: Cambiar el valor de la variable <code>x</code> a <code>nil</code>. En el ejemplo se puede observar que <code>var</code> se expande al valor que corresponde (por el operador <code>,</code>), mientras que <code>setq</code> y <code>nil</code> no se evalúan.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb20-1" data-line-number="1">(<span class="kw">defmacro</span><span class="fu"> nil</span>! (var)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  `(<span class="kw">setq</span> ,var <span class="kw">nil</span>))</a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="co">; se llama de la forma</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">(nil! x)</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="co">; genera el código</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">(<span class="kw">setq</span> x <span class="kw">nil</span>)</a></code></pre></div>
<ul>
<li><code>(if test then else)</code>: Ya se encuentra definida en Lisp. Tiene que ser una macro para evaluar la expresión solo cuando corresponda. Una posible implementación utilizaría la macro <code>cond</code>, que evalúa solo la primer expresión cuya condición sea true:</li>
</ul>
<div class="sourceCode" id="cb21"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb21-1" data-line-number="1">(<span class="kw">defmacro</span><span class="fu"> if </span>(<span class="kw">condition</span> then else)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  `(<span class="kw">cond</span> (,<span class="kw">condition</span> ,then)</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">         (<span class="kw">t</span> ,else)))</a></code></pre></div>
<ul>
<li><code>(when test do1 do2 ...)</code>: Cuando la expresión <code>test</code> devuelve <code>true</code>, se ejecutan todas las expresiones <code>do</code>, devolviendo el valor de la última. Para que se expandan todas las expresiones <code>do</code> se las combina en una lista <code>&amp;rest body</code> y luego se utiliza el operador <code>,@</code>:</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb22-1" data-line-number="1">(<span class="kw">defmacro</span><span class="fu"> our-when </span>(test &amp;<span class="kw">rest</span> body)</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">  `(<span class="kw">if</span> ,test</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    (<span class="kw">progn</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">      ,@body)))</a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="co">; se llama de la forma</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">(<span class="kw">when</span> test do1 do2 do3)</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"></a>
<a class="sourceLine" id="cb22-9" data-line-number="9"><span class="co">; genera el código</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">(<span class="kw">if</span> (eligible obj)</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">  (<span class="kw">progn</span> do1</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">    do2</a>
<a class="sourceLine" id="cb22-13" data-line-number="13">    do3</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">    obj))</a></code></pre></div>
<ul>
<li><code>infix</code>: Las macros permiten cambiar el orden de las expresiones sin evaluarlas. Entonces, se podría hacer una macro <code>infix</code> para tener operadores matemáticos en notación de infijo en vez de la notación polaca de Lisp. Existen implementaciones completas de esta macro para que funcione con más de una operación, pero para mostrar la más simple:</li>
</ul>
<div class="sourceCode" id="cb23"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb23-1" data-line-number="1">(<span class="kw">defmacro</span><span class="fu"> infix </span>(arg1 op arg2)</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  `(,op ,arg1 ,arg2))</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="co">; se llama de la forma</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">(infix <span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb23-6" data-line-number="6"></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"><span class="co">; genera el código</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8">(<span class="op">+</span> <span class="dv">2</span> <span class="dv">3</span>)</a></code></pre></div>
<ul>
<li><code>lcomp</code>: Replicar la sintaxis de compresión de listas de Python.</li>
</ul>
<div class="sourceCode" id="cb24"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb24-1" data-line-number="1">(<span class="kw">defmacro</span><span class="fu"> lcomp </span>(expression for var in <span class="kw">list</span> conditional conditional-test)</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  (<span class="kw">let</span> ((result (<span class="kw">gensym</span>)))</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    `(<span class="kw">let</span> ((,result <span class="kw">nil</span>))</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">       (<span class="kw">loop</span> for ,var in ,<span class="kw">list</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">            ,conditional ,conditional-test</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">            <span class="kw">do</span> (<span class="kw">setq</span> ,result (<span class="kw">append</span> ,result (<span class="kw">list</span> ,expression))))</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">       ,result)))</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="co">; se llama de la forma</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">(lcomp x for x in (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span> <span class="dv">7</span>) <span class="kw">if</span> (<span class="op">=</span> (<span class="kw">mod</span> x <span class="dv">2</span>) <span class="dv">0</span>))</a>
<a class="sourceLine" id="cb24-11" data-line-number="11"></a>
<a class="sourceLine" id="cb24-12" data-line-number="12"><span class="co">; una vez generado y ejecutado el código devuelve</span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13">(<span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span>)</a></code></pre></div>
<ul>
<li><code>let</code>:</li>
</ul>
<div class="sourceCode" id="cb25"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb25-1" data-line-number="1">(<span class="kw">defmacro</span><span class="fu"> let </span>(binds &amp;body body)</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  &#39;((<span class="kw">lambda</span> ,(<span class="kw">mapcar</span> #&#39;(<span class="kw">lambda</span> (x)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">                         (<span class="kw">if</span> (<span class="kw">consp</span> x) (<span class="kw">car</span> x) x))</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">                        binds)</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">      ,@body)</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">    ,@(<span class="kw">mapcar</span> #&#39;(<span class="kw">lambda</span> (x)</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">                  (<span class="kw">if</span> (<span class="kw">consp</span> x) (<span class="kw">cadr</span> x) <span class="kw">nil</span>))</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">              binds)))</a></code></pre></div>
<ul>
<li><code>while</code>:</li>
</ul>
<div class="sourceCode" id="cb26"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb26-1" data-line-number="1">(<span class="kw">defmacro</span><span class="fu"> while </span>(test &amp;body body)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  &#39;(<span class="kw">do</span> ()</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">       ((<span class="kw">not</span> ,test))</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">       ,@body))</a></code></pre></div>
<ul>
<li><code>till</code>:</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb27-1" data-line-number="1">(<span class="kw">defmacro</span><span class="fu"> till </span>(test &amp;body body)</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  &#39;(<span class="kw">do</span> ()</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">       (,test)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">       ,@body))</a></code></pre></div>
<ul>
<li><code>for</code>:</li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb28-1" data-line-number="1">(<span class="kw">defmacro</span><span class="fu"> for </span>((var start stop) &amp;body body)</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  (<span class="kw">let</span> ((gstop (<span class="kw">gensym</span>)))</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">    &#39;(<span class="kw">do</span> ((,var ,start (<span class="op">1+</span> ,var))</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">          (,gstop ,stop))</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">         ((<span class="op">&gt;</span> ,var ,gstop))</a>
<a class="sourceLine" id="cb28-6" data-line-number="6">       ,@body)))</a></code></pre></div>
</section></section>
<section><section id="desglosando-eval" class="title-slide slide level1"><h1>Desglosando <code>eval</code></h1></section><section id="section-1" class="slide level2">
<h2></h2>
<p><img data-src="img/eval.png" /></p>
<blockquote>
<p>That was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.</p>
</blockquote>
<p>~ Alan Kay, <a href="https://queue.acm.org/detail.cfm?id=1039523">A Conversation with Alan Kay</a></p>
</section><section id="section-2" class="slide level2">
<h2></h2>
<div class="sourceCode" id="cb29"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="co">;; Anotaciones sobre el código de Paul Graham en Roots of Lisp</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="co">; The Lisp defined in McCarthy&#39;s 1960 paper, translated into Common Lisp.</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="co">; eval recibe una expresion `e` y una lista de argumentos `a` -&gt; El &quot;entorno&quot;</span></a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="co">; Básicamente, recibe todo el scope donde estoy parado</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">(<span class="kw">defun</span><span class="fu"> eval </span>(e a)</a>
<a class="sourceLine" id="cb29-7" data-line-number="7">  <span class="co">; Es todo un if grande de 4 condiciones que chequean el tipo de la expresion</span></a>
<a class="sourceLine" id="cb29-8" data-line-number="8">  (<span class="kw">cond</span></a>
<a class="sourceLine" id="cb29-9" data-line-number="9">    <span class="co">; Si es un atomo -&gt; Devuelvo su valor en el entorno</span></a>
<a class="sourceLine" id="cb29-10" data-line-number="10">    ((<span class="kw">atom</span> e) (<span class="kw">assoc</span> e a))</a>
<a class="sourceLine" id="cb29-11" data-line-number="11">    <span class="co">; Si no es un atomo tiene que ser una lista</span></a>
<a class="sourceLine" id="cb29-12" data-line-number="12">    <span class="co">; Si es una lista del tipo (atomo...resto) -&gt; Es una función!</span></a>
<a class="sourceLine" id="cb29-13" data-line-number="13">    <span class="co">; (car e) es el operador</span></a>
<a class="sourceLine" id="cb29-14" data-line-number="14">    <span class="co">; (cadr e) es (car (cdr e)) que es el primero de los argumentos</span></a>
<a class="sourceLine" id="cb29-15" data-line-number="15">    ((<span class="kw">atom</span> (<span class="kw">car</span> e))</a>
<a class="sourceLine" id="cb29-16" data-line-number="16">     <span class="co">; Si Es una funcion, ¿que funcion es?</span></a>
<a class="sourceLine" id="cb29-17" data-line-number="17">     (<span class="kw">cond</span></a>
<a class="sourceLine" id="cb29-18" data-line-number="18">       <span class="co">; Si es quote, solo devuelvo los argumentos de la funcion</span></a>
<a class="sourceLine" id="cb29-19" data-line-number="19">       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;quote) (<span class="kw">cadr</span> e))</a>
<a class="sourceLine" id="cb29-20" data-line-number="20">       <span class="co">; Para el resto de los axiomas, llamo a esa funcion contra los argumentos</span></a>
<a class="sourceLine" id="cb29-21" data-line-number="21">       <span class="co">; Como quiero llamar a la operacion contra los valores de los argumentos, llamo a eval</span></a>
<a class="sourceLine" id="cb29-22" data-line-number="22">       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;atom)  (<span class="kw">atom</span>   (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)))</a>
<a class="sourceLine" id="cb29-23" data-line-number="23">       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;eq)    (<span class="kw">eq</span>     (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)</a>
<a class="sourceLine" id="cb29-24" data-line-number="24">                                    (<span class="kw">eval</span> (<span class="kw">caddr</span> e) a)))</a>
<a class="sourceLine" id="cb29-25" data-line-number="25">       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;car)   (<span class="kw">car</span>    (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)))</a>
<a class="sourceLine" id="cb29-26" data-line-number="26">       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;cdr)   (<span class="kw">cdr</span>    (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)))</a>
<a class="sourceLine" id="cb29-27" data-line-number="27">       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;cons)  (<span class="kw">cons</span>   (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)</a>
<a class="sourceLine" id="cb29-28" data-line-number="28">                                    (<span class="kw">eval</span> (<span class="kw">caddr</span> e) a)))</a>
<a class="sourceLine" id="cb29-29" data-line-number="29">       <span class="co">; cond tiene que evaluar recursivamente todas las condiciones, hasta encontrar el primer true</span></a>
<a class="sourceLine" id="cb29-30" data-line-number="30">       <span class="co">; para eso, se define una funcion auxiliar, `evcon` que recorre la lista de parametros y los evalua</span></a>
<a class="sourceLine" id="cb29-31" data-line-number="31">       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;cond)  (evcon (<span class="kw">cdr</span> e) a))</a>
<a class="sourceLine" id="cb29-32" data-line-number="32">       <span class="co">; el caso final es recibir una funcion definida por el usuario</span></a>
<a class="sourceLine" id="cb29-33" data-line-number="33">       (&#39;t (<span class="kw">eval</span> (<span class="kw">cons</span> (<span class="kw">assoc</span> (<span class="kw">car</span> e) a)</a>
<a class="sourceLine" id="cb29-34" data-line-number="34">                        (<span class="kw">cdr</span> e))</a>
<a class="sourceLine" id="cb29-35" data-line-number="35">                  a))))</a>
<a class="sourceLine" id="cb29-36" data-line-number="36">    <span class="co">; Si no es un atomo ni una lista que comienza por un atomo, entonces es una lista que comienza por otra cosa</span></a>
<a class="sourceLine" id="cb29-37" data-line-number="37">    <span class="co">; Si es una lista que comienza con label, evaluo la funcion a la que refiere</span></a>
<a class="sourceLine" id="cb29-38" data-line-number="38">    ((<span class="kw">eq</span> (<span class="kw">caar</span> e) &#39;label)</a>
<a class="sourceLine" id="cb29-39" data-line-number="39">     (<span class="kw">eval</span> (<span class="kw">cons</span> (<span class="kw">caddar</span> e) (<span class="kw">cdr</span> e))</a>
<a class="sourceLine" id="cb29-40" data-line-number="40">            (<span class="kw">cons</span> (<span class="kw">list</span> (<span class="kw">cadar</span> e) (<span class="kw">car</span> e)) a)))</a>
<a class="sourceLine" id="cb29-41" data-line-number="41">    <span class="co">; Si es una lista que comienza con lambda, evaluo sus parametros</span></a>
<a class="sourceLine" id="cb29-42" data-line-number="42">    ((<span class="kw">eq</span> (<span class="kw">caar</span> e) &#39;lambda)</a>
<a class="sourceLine" id="cb29-43" data-line-number="43">     (<span class="kw">eval</span> (<span class="kw">caddar</span> e)</a>
<a class="sourceLine" id="cb29-44" data-line-number="44">            (<span class="kw">append</span> (pair (<span class="kw">cadar</span> e) (evlis  (<span class="kw">cdr</span> e) a))</a>
<a class="sourceLine" id="cb29-45" data-line-number="45">                     a)))))</a></code></pre></div>
</section></section>
<section><section id="lisp-en-la-practica" class="title-slide slide level1"><h1>LISP en la practica</h1></section><section id="estadisticas" class="slide level2">
<h2>Estadisticas</h2>
<ul>
<li>repos de github</li>
</ul>
<p><em>Se incluyen estadísticas de uso del lenguaje, frameworks y la evolución en los últimos años. Para lenguajes antiguos se incluye información sobre qué lenguajes o técnicas se vieron influenciadas por este lenguaje</em></p>
<p>http://blockml.awwapps.com/example/example/document.html#sec-6</p>
</section><section id="comparaciones" class="slide level2">
<h2>Comparaciones</h2>
<ul>
<li>repetir tema de la influencia y de como todo lenguaje se ve tocado por lisp</li>
<li>comparar con python</li>
<li>con C performance</li>
<li>con oz, scala, haskell</li>
<li>con dialectos de lisp como scheme y racket</li>
<li>con javascript para decir como se influencia por shcem</li>
</ul>
</section><section id="familias-de-lisp" class="slide level2">
<h2>Familias de Lisp</h2>
<ul>
<li>Más usados: Scheme (1975),Emacs Lisp (1985) y Clojure (2007).</li>
</ul>
<p>Hoy, los dialectos de Lisp más ampliamente usados, ademas de Common Lisp, son Scheme (1975),Emacs Lisp (1985) y Clojure (2007).</p>
<h3 id="scheme">Scheme</h3>
<ul>
<li>Minimalista, solamente define el inner core del lenguaje</li>
<li>Sistema de macros limpio y transparente</li>
<li>Lexical scoping</li>
<li>Garbage collection</li>
<li>Ocupa mucha menos memoria</li>
</ul>
<h3 id="clojure">Clojure</h3>
<ul>
<li>Sistema de macros similar al de Common Lisp</li>
<li>Secuencias lazy (<code>seq</code>)</li>
<li>Sistema integrado de estructuras de datos persistentes e inmutables.</li>
<li>Compilado con Java</li>
</ul>
<h3 id="emacs-lisp">Emacs Lisp</h3>
<ul>
<li>Dynamic scoping por default.</li>
<li>Sintaxis para el compilado de un archivo <code>M-x byte-compile-file</code></li>
<li>No tiene closures</li>
</ul>
</section><section id="otros-lenguajes" class="slide level2">
<h2>Otros lenguajes</h2>
<h3 id="python">Python</h3>
<ul>
<li>Python admite todas las caracteristicas esenciales de Lisp, exeptuando las macros.</li>
<li>Sintaxis más sencilla de leer,</li>
<li>Tiempo de compilacion más rápido</li>
<li>Tiempo de ejecución mucho más lento</li>
<li>Más dinámico, python realiza menos chequeos de erorres.</li>
<li>Similitudes:
<ul>
<li>Lenguaje de alto nivel interpretado y compiladom orientado a objetos con semántica dinámica.</li>
<li>Admiten modulos y paquetes, fomentando la modularidad del programa.</li>
<li>Debuggear es sencillo</li>
</ul></li>
</ul>
<h3 id="c">C++</h3>
<ul>
<li>Lisp es una o dos veces más lento que C++</li>
<li>Manejo de memoria con punteros</li>
<li>Sintaxis más detallada y restrictiva</li>
</ul>
</section><section id="casos-de-estudio" class="slide level2">
<h2>Casos de estudio</h2>
<p><em>Se mencionan casos reales indicando el motivo por el cual se sabe o se cree que se usa el lenguaje</em></p>
<p>emacs</p>
<p>crash bandicoot</p>
<p>beating the averages!!!! (http://www.paulgraham.com/avg.html)</p>
<p>Reddit</p>
<p>https://github.com/CodyReichert/awesome-cl</p>
</section></section>
    </div>
  </div>

  <script src="./reveal.js/lib/js/head.min.js"></script>
  <script src="./reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: './reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: './reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
