<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>(Common) LISP</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/css/reset.css">
  <link rel="stylesheet" href="./reveal.js/css/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./reveal.js/css/theme/simple.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? './reveal.js/css/print/pdf.css' : './reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="./reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">(Common) LISP</h1>
  <p class="author"><div class="line-block">del Mazo, Federico - 100029<br />
Di Santo, Javier - 101696<br />
Dvorkin, Camila - 101109<br />
Secchi, Anita - 99131</div></p>
</section>

<section class="slide level2">

<p><a href="https://github.com/FdelMazo/7531-TDL"><img data-src="img/byte.png" /></a></p>
</section>
<section>
<section id="historia" class="title-slide slide level1">
<h1>Historia</h1>
<p><a href="https://campus.hesge.ch/Daehne/2004-2005/Langages/Lisp.htm">Early LISP History (1956 - 1959) ~ Herbert Stoyan</a></p>
<p><a href="http://www-formal.stanford.edu/jmc/history/lisp/lisp.html">History of Lisp ~ John McCarthy</a></p>
<p><a href="http://www.paulgraham.com/icad.html">Revenge of the Nerds ~ Paul Graham</a></p>
<p><a href="https://youtu.be/hGY3uBHVVr4">Lets LISP like it’s 1959</a> // <a href="https://lwn.net/Articles/778550/">LISP and the foundations of computing</a></p>
<p><a href="https://wiki.c2.com/?WhyLisp">Why Lisp ~ WikiWikiWeb</a></p>
</section>
<section id="section" class="slide level2">
<h2></h2>
<p><img data-src="img/mccarthy.png" /></p>
<blockquote>
<p>“Programming is the problem of describing procedures or algorithms to an electronic calculator.”</p>
</blockquote>
<p>~ John McCarthy, The Programming Problem</p>
</section>
<section id="por-qué-nace-lisp" class="slide level2">
<h2>¿Por qué nace LISP?</h2>
<ul>
<li><p>Un lenguaje de programación para Inteligencia Artificial Simbólica.</p>
<ul>
<li>¿Cómo se representa el conocimiento humano en términos computacionales?</li>
</ul></li>
<li><p>McCarthy busca un lenguaje: Explicito, universal, conciso.</p></li>
<li><p>Una respuesta al modelo secuencial (la máquina de Turing) y al paradigma imperativo (FORTRAN).</p></li>
</ul>
</section>
<section id="cómo-nace-lisp" class="slide level2">
<h2>¿Cómo nace LISP?</h2>
<p><strong>Idea</strong></p>
<ul>
<li><p>En los 50 se empiezan a desarrollar los primeros lenguajes de alto nivel (FLOW-MATIC, FORTRAN)</p></li>
<li><p>En 1956, en una conferencia de AI, McCarthy se inspira para comenzar a diseñar LISP (LISt Proccessing) usando:</p>
<ul>
<li><p>Las ideas de procesamiento de listas y recursión de IPL-II</p></li>
<li><p>El alto nivel de FORTRAN (1957) y su expresión algebraica.</p></li>
<li><p>La notación del cálculo Lambda de Alonzo Church.</p></li>
</ul></li>
</ul>
</section>
<section id="cálculo-lambda" class="slide level2">
<h2>Cálculo Lambda</h2>
<p><strong>λx . x+x</strong></p>
<p><a href="https://youtu.be/eis11j_iGMs">Lambda calculus ~ Computerphile</a></p>
<p><a href="https://www.jtolio.com/2017/03/whiteboard-problems-in-pure-lambda-calculus/">Whiteboard problems in pure Lambda calculus</a></p>
<p><a href="http://www.flownet.com/ron/lambda-calculus.html">The Awesome Power of Theory, Explorations in the untyped lambda calculus ~ Ron Garret</a></p>
<p><a href="https://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/church.pdf">“An Unsolvable Problem Of Elementary Number Theory” (1936) ~ Alonzo Church</a></p>
<p><a href="http://www.csc.villanova.edu/~beck/csc8310/BackusFP.pdf">“Can Programming Be Liberated from the von Neumann Style?” (1977) ~ John Backus</a></p>
<ul>
<li><p>No hay estado interno</p></li>
<li><p>Solo tiene:</p>
<ul>
<li><p>Identificadores (variables)</p></li>
<li><p>Expresiones lambda (construcción de funciones)</p></li>
<li><p>Aplicación de funciones</p></li>
</ul></li>
<li><p>Church–Turing thesis: la notación Lambda es formalmente equivalente a una máquina de Turing</p></li>
</ul>
</section>
<section id="cómo-nace-lisp-1" class="slide level2">
<h2>¿Cómo nace LISP?</h2>
<p><strong>Definición</strong></p>
<ul>
<li><p><a href="http://www.softwarepreservation.org/projects/LISP/MIT/AIM-001.pdf">“An Algebraic Language for the Manipulation of Symbolic Expression” (1958) ~ John McCarthy</a></p>
<ul>
<li><p>Primer diseño (incompleto) de LISP.</p></li>
<li><p>Comienzos de la programación funcional.</p></li>
</ul></li>
<li><p><a href="http://www-formal.stanford.edu/jmc/recursive.pdf">“Recursive Functions of Symbolic Expressionsand Their Computation by Machine, Part I” (1960) ~ John McCarthy</a></p>
<ul>
<li><p>Especificación completa de LISP, un lenguaje <em>teórico</em>, que no estaba pensado para ser implementado.</p></li>
<li><p>Solución más comprensible a la máquina de Turing.</p></li>
<li><p>Para demostrar que es Turing-Completo, define una “función universal de LISP”, que luego llegaría a ser <code>eval</code>.</p></li>
</ul></li>
</ul>
</section>
<section id="cómo-nace-lisp-2" class="slide level2">
<h2>¿Cómo nace LISP?</h2>
<p><strong>Implementación</strong></p>
<ul>
<li><p>1960: Steve Russell, un alumno de McCarthy, decide probar e implementar en código máquina <code>eval</code></p>
<ul>
<li>Primer interprete de LISP, para la IBM 704.</li>
</ul></li>
<li><p>1962: Tim Hart y Mike Levin hacen el primer compilador de LISP.</p>
<ul>
<li><p>Lo más cercano al LISP que conocemos hoy en día.</p></li>
<li><p>Funciones compiladas e interpretadas pueden ser intercambiadas libremente.</p></li>
</ul></li>
</ul>
</section>
<section id="pionero" class="slide level2">
<h2>Pionero</h2>
<p><a href="http://www.paulgraham.com/diff.html">What Made Lisp Different ~ Paul Graham</a></p>
<p><a href="https://www.informit.com/articles/article.aspx?p=1671639">Influential Programming Languages, Lisp ~ David Chisnall</a></p>
<ul>
<li><p><strong>if then else</strong></p></li>
<li><p><strong>Funciones</strong> como objetos de primera clase</p></li>
<li><p><strong>Recursión</strong></p></li>
<li><p>Todas las variables son <strong>punteros</strong></p></li>
<li><p><strong>Garbarge Collection automático</strong></p></li>
<li><p><strong>Tipado dinámico</strong></p></li>
<li><p><strong>Interactividad</strong> gracias al interprete <strong>REPL</strong></p></li>
<li><p>Programas compuestos por <strong>expresiones</strong></p></li>
<li><p>El lenguaje completo está siempre disponible</p></li>
<li><p><strong>Map y Reduce</strong></p></li>
</ul>
</section></section>
<section>
<section id="sintaxis" class="title-slide slide level1">
<h1>Sintaxis</h1>
<p><a href="http://web.cse.ohio-state.edu/~rountev.1/6341/pdf/Manual.pdf">LISP 1.5 Programmer’s Manual</a></p>
<p><a href="http://clhs.lisp.se/Front/index.htm">Common Lisp HyperSpec</a></p>
<p><a href="https://learnxinyminutes.com/docs/common-lisp/">Learn X in Y minutes, Where X=Common Lisp</a></p>
</section>
<section id="expresiones---átomos-y-listas" class="slide level2">
<h2>Expresiones -&gt; átomos y listas</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">;; Todo en LISP se compone de symbolic expressions</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dv">1</span> <span class="co">; Una s-expression puede ser un átomo -&gt; irreducible</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>) <span class="co">; Una s-expression puede ser una lista -&gt; partible</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">;; Las s-expressions evaluan a valores</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="dv">2</span> <span class="co">; evalua a 2</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>(<span class="op">+</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; evalua a 5</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>(<span class="op">+</span> (<span class="op">+</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="dv">2</span>) <span class="co">; (+ 2 3) evalua a 5 -&gt; todo evalua a 7</span></span></code></pre></div>
</section>
<section id="code-data---eval-quote" class="slide level2">
<h2>Code &amp; Data -&gt; <code>eval</code>, <code>quote</code></h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">;; El operador quote toma una s-expression y devuelve el código que la genera</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>) <span class="co">; evalua a 2</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>(<span class="kw">quote</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a (+ 1 1)</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>(&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; quote se abrevia a &#39;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="co">;; El operador eval toma una s-expresion y devuelve su valor</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>(<span class="kw">eval</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a 2</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>(<span class="kw">eval</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a 2</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>(<span class="kw">eval</span> &#39;&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">1</span>)) <span class="co">; evalua a (+ 1 1)</span></span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="co">;; 1 + 1 es 2</span></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co">;; &quot;1 + 1&quot; es el código 1 + 1</span></span></code></pre></div>
<p>Puedo hacer un programa entero, ponerle un <code>'</code> adelante, y estoy tratando con el <strong>código</strong> de mi programa.</p>
</section>
<section id="procesar-listas---car-cdr-cons-y-list" class="slide level2">
<h2>Procesar listas -&gt; <code>car</code>, <code>cdr</code>, <code>cons</code> y <code>list</code></h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">;; car recibe una lista y devuelve su primer elemento</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>(<span class="kw">car</span> (<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; explota, no recibio una lista</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>(<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; devuelve +</span></span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">;; cdr recibe una lista y devuelve el resto (todo menos el primer elemento)</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>(<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) <span class="co">; devuelve (1 2)</span></span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co">;; cons crea un cons de un valor seguido de una lista</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co">;; AKA agrega un valor al principio de la lista</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>(<span class="kw">cons</span> &#39;<span class="dv">1</span> &#39;(<span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; devuelve (1 2 3)</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>(<span class="kw">cons</span> &#39;+ &#39;(<span class="dv">2</span> <span class="dv">3</span>)) <span class="co">; devuelve (+ 2 3)</span></span>
<span id="cb3-12"><a href="#cb3-12"></a></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co">;; list compone una lista de sus argumentos</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>(<span class="kw">list</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; devuelve (1 2 3)</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>(<span class="kw">list</span> &#39;+ <span class="dv">2</span> <span class="dv">3</span>) <span class="co">; devuelve (+ 2 3)</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">;; si tan solo hubiese una manera de ejecutar esta expresion!</span></span></code></pre></div>
</section>
<section id="procesar-una-s-expression---programming-bottom-up" class="slide level2">
<h2>Procesar una s-expression -&gt; Programming Bottom Up</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">;; Partimos de la expresion (+ 1 2)</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">;; La convertimos en el código de la expresion</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>&#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">;; Sacamos su operador -&gt; el +</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>(<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">;; Sacamos los operandos -&gt; el (1 2)</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>(<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="co">;; Empaquetamos esto nuevamente -&gt; (+ 1 2)</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>(<span class="kw">cons</span> (<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) (<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)))</span>
<span id="cb4-11"><a href="#cb4-11"></a><span class="co">;; Evaluamos la expresion</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>(<span class="kw">eval</span> (<span class="kw">cons</span> (<span class="kw">car</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>)) (<span class="kw">cdr</span> &#39;(<span class="op">+</span> <span class="dv">1</span> <span class="dv">2</span>))))</span></code></pre></div>
</section></section>
<section id="fractales-en-common-lisp" class="title-slide slide level1">
<h1>Fractales, en Common LISP</h1>
<p><a href="https://github.com/FdelMazo/cl-aristid">cl-aristid</a></p>
<p>Lindenmayer system</p>
<ul>
<li>Alfabeto: F, LEFT, RIGHT</li>
<li>Axioma: F X</li>
<li>Reglas de producción:
<ul>
<li>X -&gt; (X RIGHT Y F RIGHT)</li>
<li>Y -&gt; (LEFT F X LEFT Y)</li>
</ul></li>
</ul>
<p><img data-src="img/dragon_010_animated.svg" /></p>
</section>

<section>
<section id="ejemplo-de-tda-tablas-de-hash" class="title-slide slide level1">
<h1>Ejemplo de TDA: Tablas de hash</h1>
<p><a href="https://github.com/muditbac/Reading/blob/master/programming/(Prentice%20Hall%20series%20in%20artificial%20intelligence)%20Paul%20Graham-ANSI%20Common%20LISP-Prentice%20Hall%20(1996).pdf">ANSI Common Lisp, Chapter 4: Specialized Data Structures ~ Paul Graham</a></p>
<p><a href="http://cl-cookbook.sourceforge.net/hashes.html">The Common Lisp Cookbook - Hash Tables</a></p>
</section>
<section id="crear-una-tabla-de-hash-en-common-lisp" class="slide level2">
<h2>Crear una tabla de hash en Common Lisp</h2>
<ul>
<li>función <code>make-hash-table</code></li>
<li>No requiere ningún argumento, pero el opcional más usado es <code>:TEST</code> (testear claves iguales)</li>
</ul>
<p>Ejemplo:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb5-1"><a href="#cb5-1"></a>(<span class="kw">defvar</span><span class="fu"> tabla</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a>(<span class="kw">setq</span> tabla (<span class="kw">make-hash-table</span> <span class="bu">:test</span> &#39;equal))</span></code></pre></div>
</section>
<section id="agregar-un-elemento-a-la-tabla" class="slide level2">
<h2>Agregar un elemento a la tabla</h2>
<ul>
<li>función <code>gethash</code> en conjunto con la función <code>setf</code></li>
</ul>
<div class="sourceCode" id="cb6"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb6-1"><a href="#cb6-1"></a><span class="op">*</span> (<span class="kw">setf</span> (<span class="kw">gethash</span> <span class="st">&quot;clave1&quot;</span> tabla) <span class="dv">3</span>) <span class="co">; gethash recibe dos argumentos: la clave y el hash</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="dv">3</span></span></code></pre></div>
</section>
<section id="obtener-un-valor" class="slide level2">
<h2>Obtener un valor</h2>
<ul>
<li>función <code>gethash</code> toma dos argumentos obligatorios: una clave y una tabla de hash</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb7-1"><a href="#cb7-1"></a><span class="op">*</span> (<span class="kw">setf</span> (<span class="kw">gethash</span> <span class="st">&quot;clave1&quot;</span> tabla) <span class="dv">3</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="dv">3</span></span></code></pre></div>
</section>
<section id="borrar-de-la-tabla-de-hash" class="slide level2">
<h2>Borrar de la tabla de hash</h2>
<ul>
<li>función <code>remhash</code> para eliminar el par clave-valor</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb8-1"><a href="#cb8-1"></a><span class="op">*</span> (<span class="kw">remhash</span> <span class="st">&quot;clave1&quot;</span> tabla) <span class="co">; elimino el par: &quot;clave&quot;-3</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>T</span></code></pre></div>
</section>
<section id="contar-entradas" class="slide level2">
<h2>Contar entradas</h2>
<ul>
<li>función <code>hash-table-count</code></li>
</ul>
<div class="sourceCode" id="cb9"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb9-1"><a href="#cb9-1"></a><span class="op">*</span> (<span class="kw">hash-table-count</span> tabla)</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="dv">3</span> <span class="co">; 3 elementos en mi hash.</span></span></code></pre></div>
</section>
<section id="el-tamaño-del-hash" class="slide level2">
<h2>El tamaño del hash</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb10-1"><a href="#cb10-1"></a><span class="op">*</span> (<span class="kw">setq</span> tabla (<span class="kw">make-hash-table</span> <span class="bu">:test</span> &#39;equal))</span>
<span id="cb10-2"><a href="#cb10-2"></a>#&lt;HASH-TABLE :TEST EQUAL :COUNT <span class="dv">0</span> {10058B8553}<span class="op">&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="op">*</span>(<span class="kw">hash-table-size</span> tabla)</span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="dv">16</span> <span class="co">; por default</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="op">*</span>(<span class="kw">hash-table-rehash-size</span> tabla)</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="fl">1.5</span> <span class="co">; indica que la tabla se agrandará en un 50% cada vez que necesite crecer.</span></span></code></pre></div>
<ul>
<li>Ejemplo: agregar un total de un millón* de pares clave-valor al hash y ver como se redimensiona</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb11-1"><a href="#cb11-1"></a><span class="op">*</span> (<span class="kw">time</span> (<span class="kw">dotimes</span> (n <span class="dv">1000000</span>) (<span class="kw">setf</span> (<span class="kw">gethash</span> n tabla) n))) <span class="co">; le tomo el tiempo que tarda</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>Evaluation took:</span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="fl">0.162</span> seconds of <span class="kw">real</span> <span class="kw">time</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>  <span class="fl">0.161954</span> seconds of total run <span class="kw">time</span> (<span class="fl">0.137696</span> <span class="kw">user</span>, <span class="fl">0.024258</span> <span class="kw">system</span>)</span>
<span id="cb11-5"><a href="#cb11-5"></a>  [ Run times consist of <span class="fl">0.015</span> seconds GC <span class="kw">time</span>, <span class="kw">and</span> <span class="fl">0.147</span> seconds non-GC <span class="kw">time</span>. ]</span>
<span id="cb11-6"><a href="#cb11-6"></a>  <span class="fl">100.00</span>% CPU</span>
<span id="cb11-7"><a href="#cb11-7"></a>  <span class="dv">355</span>,<span class="dv">501</span>,<span class="dv">132</span> processor cycles</span>
<span id="cb11-8"><a href="#cb11-8"></a>  <span class="dv">83</span>,<span class="dv">836</span>,<span class="dv">896</span> bytes consed</span>
<span id="cb11-9"><a href="#cb11-9"></a>NIL</span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="op">*</span> (<span class="kw">hash-table-count</span> tabla)</span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="dv">1000000</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="op">*</span> (<span class="kw">hash-table-size</span> tabla)</span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="dv">1048576</span></span></code></pre></div>
<p>*<em>Se eligió un millón para resaltar los tiempos que tardan</em></p>
</section>
<section id="fun-stuff-e-iteradores-del-hash" class="slide level2">
<h2>Fun stuff e iteradores del hash</h2>
<ul>
<li><code>maphash</code>: itera sobre todas las claves de la tabla. Devuelve siempre <code>NIL</code>.</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb12-1"><a href="#cb12-1"></a><span class="op">*</span> (<span class="kw">defun</span><span class="fu"> imprimir-entrada </span>(clave valor) (<span class="kw">format</span> <span class="kw">t</span> <span class="st">&quot;El valor asociado a la clave ~S es ~S~%&quot;</span> clave valor)) <span class="co">; partimos de un hash con 3 claves</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>IMPRIMIR-ENTRADA</span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="op">*</span> (<span class="kw">maphash</span> #&#39;imprimir-entrada tabla)</span>
<span id="cb12-4"><a href="#cb12-4"></a>El valor asociado a la clave <span class="st">&quot;clave1&quot;</span> es <span class="dv">1</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>El valor asociado a la clave <span class="st">&quot;clave2&quot;</span> es <span class="dv">2</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>El valor asociado a la clave <span class="st">&quot;clave3&quot;</span> es <span class="dv">3</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>NIL</span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="op">*</span></span></code></pre></div>
<ul>
<li><code>with-hash-table-iterator</code>: es una macro que convierte el primer argumento en un iterador que en cada invocación devuelve un booleano generalizado que es <code>true</code> si alguna entrada es devuelta, la clave, y el valor. Si no encuentra más claves, devuelve <code>NIL</code></li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb13-1"><a href="#cb13-1"></a><span class="op">*</span> (<span class="kw">with-hash-table-iterator</span> (iterador tabla)</span>
<span id="cb13-2"><a href="#cb13-2"></a>    (<span class="kw">loop</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>        (<span class="kw">multiple-value-bind</span> (entrada clave valor)</span>
<span id="cb13-4"><a href="#cb13-4"></a>            (iterador)</span>
<span id="cb13-5"><a href="#cb13-5"></a>        (<span class="kw">if</span> entrada</span>
<span id="cb13-6"><a href="#cb13-6"></a>            (imprimir-entrada clave valor)</span>
<span id="cb13-7"><a href="#cb13-7"></a>            (<span class="kw">return</span>)))))</span>
<span id="cb13-8"><a href="#cb13-8"></a>El valor asociado a la clave <span class="st">&quot;clave1&quot;</span> es <span class="dv">1</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>El valor asociado a la clave <span class="st">&quot;clave2&quot;</span> es <span class="dv">2</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>El valor asociado a la clave <span class="st">&quot;clave3&quot;</span> es <span class="dv">3</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>NIL</span></code></pre></div>
</section></section>
<section>
<section id="metaprogramming" class="title-slide slide level1">
<h1>Metaprogramming</h1>
<p><a href="https://youtu.be/dw-y3vNDRWk">Code vs Data (Metaprogramming) ~ Computerphile</a></p>
<p><a href="http://mnielsen.github.io/notes/parentheses/index.html">Why are there so many parentheses in Lisp?</a></p>
<div class="container">
<div class="col">
<p><strong>data</strong></p>
<ul>
<li><p>No hay interpretación</p>
<ul>
<li><p>Números <code>1</code></p></li>
<li><p>Cadenas <code>"uno"</code></p></li>
</ul></li>
</ul>
</div>
<div class="col">
<p><strong>code</strong></p>
<ul>
<li><p>Hay un procesamiento</p>
<ul>
<li><p>aritmética <code>1 + 2</code></p></li>
<li><p>acciones <code>print "uno"</code></p></li>
</ul></li>
</ul>
</div>
</div>
</section>
<section id="orientado-a-expresiones" class="slide level2">
<h2>Orientado a expresiones</h2>
<p><a href="https://en.wikipedia.org/wiki/Expression-oriented_programming_language">Expression-oriented programming language</a></p>
<p><a href="https://beautifulracket.com/appendix/why-racket-why-lisp.html">Why Racket? Why Lisp? ~ Beautiful Racket</a></p>
<ul>
<li><p>La mayoria de los los lenguajes distinguen entre <code>expresiones</code> y <code>sentencias</code> (statements)</p>
<ul>
<li><p>Expresión: frases que son evaluadas</p>
<ul>
<li><p>Siempre producen un valor</p></li>
<li><p>Suelen no tener efectos secundarios</p></li>
</ul></li>
<li><p>Sentencias: frases que marcan una acción</p>
<ul>
<li><p>No retornan valores</p></li>
<li><p>Se ejecutan solamente por sus efectos secundarios</p></li>
</ul></li>
</ul></li>
<li><p>En LISP, todo es una expresiónn</p>
<ul>
<li><p>Facil de testear</p></li>
<li><p>Código mas expresivo</p></li>
<li><p>Anidar expresiones de manera concisa</p></li>
</ul></li>
<li><p>Transparencia referencial: equals can be replaced by equals</p></li>
</ul>
</section>
<section id="symbolic-expression" class="slide level2">
<h2>Symbolic expression</h2>
<div class="container">
<div class="col">
<p><strong>atom</strong></p>
<p><img data-src="img/atom.png" /></p>
<p><code>x</code></p>
</div>
<div class="col">
<p><strong>construct cell</strong></p>
<p><img data-src="img/cons.png" /></p>
<p><code>(x . y)</code></p>
</div>
</div>
</section>
<section id="list" class="slide level2">
<h2>list</h2>
<p><img data-src="img/list.png" /></p>
<p><code>(x . (y . (z . NIL)))</code> === <code>(x y z)</code></p>
</section>
<section id="tree" class="slide level2">
<h2>tree</h2>
<p><img data-src="img/tree.png" /></p>
<p><code>(x y z)</code></p>
</section>
<section id="s-expressions" class="slide level2">
<h2>s-expressions</h2>
<p><img data-src="img/sexp.png" /></p>
<p><code>(* (+ 1 2) (- 5 3) )</code></p>
</section>
<section id="conclusión" class="slide level2">
<h2>Conclusión</h2>
<ul>
<li><p>¿Cómo se representá mi código escrito? <strong>árbol de s-expressions</strong></p></li>
<li><p>¿Cómo se representá mi programa compilado? <strong>árbol de sintaxis abstracta (AST)</strong></p></li>
</ul>
<p><strong>La representación interna de mi código es muy parecida a mi código escrito</strong></p>
</section>
<section id="homoiconicidad" class="slide level2">
<h2>Homoiconicidad</h2>
<p><a href="https://en.wikipedia.org/wiki/Symbolic_programming">Symbolic programming</a></p>
<p><a href="https://en.wikipedia.org/wiki/Homoiconicity">Homoiconicity</a></p>
<p><a href="https://wiki.c2.com/?HomoiconicExampleInManyProgrammingLanguages">Homoiconic Example In Many Programming Languages ~ WikiWikiWeb</a></p>
<ul>
<li><p>LISP es un lenguaje simbólico: El código es un ciudadano de primera clase</p></li>
<li><p>LISP es homoicónico: su representación interna se infiere leyendo el código</p></li>
<li><p>Toda expresión se puede interpretar de las dos maneras.</p>
<ul>
<li><p>Se interpreta como data usando <code>quote</code></p></li>
<li><p>Se interpreta como código usando <code>eval</code></p></li>
</ul></li>
</ul>
<div class="sourceCode" id="cb14"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb14-1"><a href="#cb14-1"></a>(<span class="kw">setf</span> b <span class="dv">3</span>)</span>
<span id="cb14-2"><a href="#cb14-2"></a>b <span class="co">; =&gt; 3</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>(<span class="kw">setf</span> a &#39;(<span class="kw">setf</span> b <span class="dv">15</span>))</span>
<span id="cb14-4"><a href="#cb14-4"></a>a <span class="co">; =&gt; (SETF B 15)</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>(<span class="kw">eval</span> a)</span>
<span id="cb14-6"><a href="#cb14-6"></a>b    <span class="co">; =&gt; 15</span></span></code></pre></div>
</section>
<section id="macros" class="slide level2">
<h2>Macros</h2>
<ul>
<li><p>En Lisp, una macro genera y devuelve código.</p></li>
<li><p>Cuando se llama a una macro:</p></li>
</ul>
<ol type="1">
<li><p>Se arma el código en base a la definición <code>defmacro</code> de la misma.</p></li>
<li><p>Se evalúa el nuevo código en el lugar de la llamada a la macro.</p></li>
</ol>
<ul>
<li><code>macroexpand</code> devuelve el código generado por una macro.</li>
</ul>
</section>
<section id="motivación-de-macros" class="slide level2">
<h2>Motivación de macros</h2>
<ul>
<li><p>Poder elegir cuándo y cómo se evaluan los argumentos.</p></li>
<li><p>Cambiar orden de evaluación.</p></li>
<li><p>Manipular sintaxis del lenguaje.</p></li>
</ul>
</section>
<section id="a-diferencia-de-otros-lenguajes" class="slide level2">
<h2>A diferencia de otros lenguajes</h2>
<ul>
<li><p>Macros en Lisp? Se escriben sobre Lisp!</p></li>
<li><p>Macros en C? En el preprocesador de C</p></li>
</ul>
</section>
<section id="code-data-part-2---backquote-comma" class="slide level2">
<h2>Code &amp; Data (Part 2) -&gt; Backquote &amp; Comma</h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb15-1"><a href="#cb15-1"></a><span class="co">; backquote funciona similar a quote</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>`(a, b, c)</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co">; equivalente a escribir</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>&#39;(a b c)</span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="co">; combinando con comma permite &quot;activar y desactivar&quot; backquote</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>`(a ,b c ,d)</span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="co">; equivalente a escribir</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>(<span class="kw">list</span> &#39;a b &#39;c d)</span></code></pre></div>
</section>
<section id="code-data-part-3---comma-at" class="slide level2">
<h2>Code &amp; Data (Part 3) -&gt; Comma-at</h2>
<div class="sourceCode" id="cb16"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">; permite reemplazar esta lista por la secuencia de sus mismos elementos</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>`(a b c)    -&gt;  (A (<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>) C)</span>
<span id="cb16-3"><a href="#cb16-3"></a>`(a ,@b c)  -&gt;  (A <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> C)</span></code></pre></div>
</section>
<section id="extensibilidad-del-lenguaje" class="slide level2">
<h2>Extensibilidad del lenguaje</h2>
<ul>
<li><p>Programa extensible: permite al usuario agregar funcionalidad.</p></li>
<li><p>Macros permiten que Lisp sea un lenguaje extensible.</p></li>
</ul>
</section>
<section id="módulos-y-lenguajes-de-dominio-específico-dsl" class="slide level2">
<h2>Módulos y lenguajes de dominio específico [DSL]</h2>
<ul>
<li><p><strong>Common Lisp Object System [CLOS]</strong>: agrega un sistema de objetos a Lisp.</p></li>
<li><p><strong>lparallel</strong>: agrega funcionalidad para la creación de hilos.</p></li>
<li><p><strong>CL-INTERPOL</strong>: para interpolación de strings.</p></li>
<li><p>Colección de librerías destacadas en <strong>awesome-cl</strong>.</p></li>
</ul>
</section>
<section id="aún-más" class="slide level2">
<h2>¿Aún más?</h2>
<p><strong>Racket</strong> es un dialecto de Scheme y parte de la familia de Lisp.</p>
<p>Está orientado específicamente a crear lenguajes nuevos.</p>
</section></section>
<section>
<section id="desglosando-eval" class="title-slide slide level1">
<h1>Desglosando <code>eval</code></h1>
<p><a href="http://www.paulgraham.com/rootsoflisp.html">The Roots of LISP ~ Paul Graham</a></p>
<p><a href="https://youtu.be/OyfBQmvr2Hc">The Most Beautiful Program Ever Written ~ William Byrd</a></p>
<ul>
<li><p>La magía de LISP es el <strong>read–eval–print loop</strong>: un entorno donde se toma lo escrito por el programador, se lee, se evalua, se imprime, y luego se vuelve a pedir input</p></li>
<li><p>Este self-interpreter es un <strong>evaluador meta-circular:</strong> esta escrito en LISP y puede evaluar código de LISP.</p></li>
<li><p>¿Cómo? Gracias a la función <code>eval</code>, definida por McCarthy en base a 7 operadores que toma como axiomas: <code>quote</code>, <code>atom</code>, <code>eq</code>, <code>car</code>, <code>cdr</code>, <code>cons</code> y <code>cond</code></p></li>
</ul>
</section>
<section id="section-1" class="slide level2">
<h2></h2>
<p><img data-src="img/eval.png" /></p>
<blockquote>
<p>That was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.</p>
</blockquote>
<p>~ Alan Kay, <a href="https://queue.acm.org/detail.cfm?id=1039523">A Conversation with Alan Kay</a></p>
</section>
<section id="section-2" class="slide level2">
<h2></h2>
<div class="sourceCode" id="cb17"><pre class="sourceCode lisp"><code class="sourceCode commonlisp"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">;; Anotaciones sobre el código de Paul Graham en Roots of Lisp</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="co">; The Lisp defined in McCarthy&#39;s 1960 paper, translated into Common Lisp.</span></span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="co">; eval recibe una expresion `e` y una lista de argumentos `a` -&gt; El &quot;entorno&quot;</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="co">; Básicamente, recibe todo el scope donde estoy parado</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>(<span class="kw">defun</span><span class="fu"> eval </span>(e a)</span>
<span id="cb17-7"><a href="#cb17-7"></a>  <span class="co">; Es todo un if grande de 4 condiciones que chequean el tipo de la expresion</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>  (<span class="kw">cond</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>    <span class="co">; Si es un atomo -&gt; Devuelvo su valor en el entorno</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>    ((<span class="kw">atom</span> e) (<span class="kw">assoc</span> e a))</span>
<span id="cb17-11"><a href="#cb17-11"></a>    <span class="co">; Si no es un atomo tiene que ser una lista</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="co">; Si es una lista del tipo (atomo...resto) -&gt; Es una función!</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>    <span class="co">; (car e) es el operador</span></span>
<span id="cb17-14"><a href="#cb17-14"></a>    <span class="co">; (cadr e) es (car (cdr e)) que es el primero de los argumentos</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>    ((<span class="kw">atom</span> (<span class="kw">car</span> e))</span>
<span id="cb17-16"><a href="#cb17-16"></a>     <span class="co">; Si Es una funcion, ¿que funcion es?</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>     (<span class="kw">cond</span></span>
<span id="cb17-18"><a href="#cb17-18"></a>       <span class="co">; Si es quote, solo devuelvo los argumentos de la funcion</span></span>
<span id="cb17-19"><a href="#cb17-19"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;quote) (<span class="kw">cadr</span> e))</span>
<span id="cb17-20"><a href="#cb17-20"></a>       <span class="co">; Para el resto de los axiomas, llamo a esa funcion contra los argumentos</span></span>
<span id="cb17-21"><a href="#cb17-21"></a>       <span class="co">; Como quiero llamar a la operacion contra los valores de los argumentos, llamo a eval</span></span>
<span id="cb17-22"><a href="#cb17-22"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;atom)  (<span class="kw">atom</span>   (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)))</span>
<span id="cb17-23"><a href="#cb17-23"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;eq)    (<span class="kw">eq</span>     (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)</span>
<span id="cb17-24"><a href="#cb17-24"></a>                                    (<span class="kw">eval</span> (<span class="kw">caddr</span> e) a)))</span>
<span id="cb17-25"><a href="#cb17-25"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;car)   (<span class="kw">car</span>    (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)))</span>
<span id="cb17-26"><a href="#cb17-26"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;cdr)   (<span class="kw">cdr</span>    (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)))</span>
<span id="cb17-27"><a href="#cb17-27"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;cons)  (<span class="kw">cons</span>   (<span class="kw">eval</span> (<span class="kw">cadr</span> e) a)</span>
<span id="cb17-28"><a href="#cb17-28"></a>                                    (<span class="kw">eval</span> (<span class="kw">caddr</span> e) a)))</span>
<span id="cb17-29"><a href="#cb17-29"></a>       <span class="co">; cond tiene que evaluar recursivamente todas las condiciones, hasta encontrar el primer true</span></span>
<span id="cb17-30"><a href="#cb17-30"></a>       <span class="co">; para eso, se define una funcion auxiliar, `evcon` que recorre la lista de parametros y los evalua</span></span>
<span id="cb17-31"><a href="#cb17-31"></a>       ((<span class="kw">eq</span> (<span class="kw">car</span> e) &#39;cond)  (evcon (<span class="kw">cdr</span> e) a))</span>
<span id="cb17-32"><a href="#cb17-32"></a>       <span class="co">; el caso final es recibir una funcion definida por el usuario</span></span>
<span id="cb17-33"><a href="#cb17-33"></a>       (&#39;t (<span class="kw">eval</span> (<span class="kw">cons</span> (<span class="kw">assoc</span> (<span class="kw">car</span> e) a)</span>
<span id="cb17-34"><a href="#cb17-34"></a>                        (<span class="kw">cdr</span> e))</span>
<span id="cb17-35"><a href="#cb17-35"></a>                  a))))</span>
<span id="cb17-36"><a href="#cb17-36"></a>    <span class="co">; Si no es un atomo ni una lista que comienza por un atomo, entonces es una lista que comienza por otra cosa</span></span>
<span id="cb17-37"><a href="#cb17-37"></a>    <span class="co">; Si es una lista que comienza con label, evaluo la funcion a la que refiere</span></span>
<span id="cb17-38"><a href="#cb17-38"></a>    ((<span class="kw">eq</span> (<span class="kw">caar</span> e) &#39;label)</span>
<span id="cb17-39"><a href="#cb17-39"></a>     (<span class="kw">eval</span> (<span class="kw">cons</span> (<span class="kw">caddar</span> e) (<span class="kw">cdr</span> e))</span>
<span id="cb17-40"><a href="#cb17-40"></a>            (<span class="kw">cons</span> (<span class="kw">list</span> (<span class="kw">cadar</span> e) (<span class="kw">car</span> e)) a)))</span>
<span id="cb17-41"><a href="#cb17-41"></a>    <span class="co">; Si es una lista que comienza con lambda, evaluo sus parametros</span></span>
<span id="cb17-42"><a href="#cb17-42"></a>    ((<span class="kw">eq</span> (<span class="kw">caar</span> e) &#39;lambda)</span>
<span id="cb17-43"><a href="#cb17-43"></a>     (<span class="kw">eval</span> (<span class="kw">caddar</span> e)</span>
<span id="cb17-44"><a href="#cb17-44"></a>            (<span class="kw">append</span> (pair (<span class="kw">cadar</span> e) (evlis  (<span class="kw">cdr</span> e) a))</span>
<span id="cb17-45"><a href="#cb17-45"></a>                     a)))))</span></code></pre></div>
</section></section>
<section>
<section id="lisp-en-la-práctica" class="title-slide slide level1">
<h1>LISP en la práctica</h1>
<p><a href="https://thomasbandt.com/who-cares-about-functional-programming">Who Cares About Functional Programming?</a></p>
</section>
<section id="stack-overflow" class="slide level2">
<h2>Stack Overflow</h2>
<p><a href="https://insights.stackoverflow.com/trends?tags=lisp%2Chaskell">Stack Overflow Trends</a></p>
<p><a href="http://blockml.awwapps.com/example/example/document.html#id-DIALECTS">Popularity of LISP</a></p>
<div class="container">
<div class="col">
<p><img data-src="img/lispvsdialects.svg" /></p>
</div>
<div class="col">
<p><img data-src="img/lispvslanguages.svg" /></p>
</div>
</div>
<blockquote>
<p>En cuanto a popularidad de LISP en preguntas dentro de stackoverflow, vemos que Common Lisp compite contra otros dialectos, pero Clojure es el más utilizado.</p>
</blockquote>
<blockquote>
<p>De todas formas, toda la familia de LISP es un porcentaje muy chico, en comparación a otros lenguajes.</p>
</blockquote>
</section>
<section id="github" class="slide level2">
<h2>GitHub</h2>
<p><a href="https://madnight.github.io/githut/#/pull_requests/2020/2">GitHut 2.0: A Small Place To Discover Languages In Github</a></p>
<p><img data-src="img/githut.png" /></p>
<blockquote>
<p>Podemos ver que la cantidad de pull requests de Common Lisp anuales son muy bajos, incluso contra otros dialectos y lenguajes</p>
</blockquote>
</section>
<section id="hacker-news" class="slide level2">
<h2>Hacker News</h2>
<p><a href="https://toddwschneider.com/dashboards/hacker-news-trends/?q=lisp%2C+haskell%2C+java&amp;f=title&amp;s=text&amp;m=items_count&amp;t=year">Hacker News Front Page Trends</a></p>
<p><img data-src="img/hackernews.png" /></p>
<blockquote>
<p>Aunque Lisp no es un lenguaje que se usa mucho en la práctica, si hay un gran interés teórico por este (hay que tener en cuenta que este foro nos da una idea de que <em>blogs</em> o <em>artículos</em> se comparten de una tecnología, en vez de usos practicos y código productivo).</p>
</blockquote>
</section>
<section id="comparaciones" class="slide level2">
<h2>Comparaciones</h2>
<p><strong>Contra otros lenguajes, y contra otros dialectos de la familia LISP</strong></p>
<p><a href="https://wiki.c2.com/?LispSchemeDifferences">Lisp Scheme Differences ~ WikiWikiWeb</a></p>
<p><a href="https://norvig.com/python-lisp.html">Python for Lisp Programmers ~ Peter Norvig</a></p>
</section>
<section id="scheme" class="slide level2">
<h2>Scheme</h2>
<ul>
<li>Minimalista, solamente define el inner core del lenguaje</li>
<li>Sistema de macros limpio y transparente</li>
<li>Lexical scoping</li>
<li>Garbage collection</li>
<li>Ocupa mucha menos memoria</li>
</ul>
</section>
<section id="python" class="slide level2">
<h2>Python</h2>
<ul>
<li>Sintaxis más sencilla de leer,</li>
<li>Tiempo de compilacion más rápido</li>
<li>Tiempo de ejecución mucho más lento</li>
<li>Más dinámico, python realiza menos chequeos de erorres.</li>
</ul>
</section>
<section id="c" class="slide level2">
<h2>C++</h2>
<ul>
<li>Lisp es una o dos veces más lento que C++</li>
<li>Manejo de memoria con punteros</li>
<li>Sintaxis más detallada y restrictiva</li>
</ul>
</section>
<section id="casos-de-estudio" class="slide level2">
<h2>Casos de estudio</h2>
<p><a href="http://www.paulgraham.com/avg.html">Beating the Averages ~ Paul Graham</a></p>
<p><a href="https://redditblog.com/2005/12/05/on-lisp/">On Lisp ~ Reddit</a></p>
<p><a href="http://www.aaronsw.com/weblog/rewritingreddit">Rewriting Reddit ~ Aaron Swartz</a></p>
<p><a href="https://all-things-andy-gavin.com/2011/10/25/lispings-ala-john-mccarthy/">Lispings ala John McCarthy ~ Andy Gavin</a></p>
<p><a href="https://all-things-andy-gavin.com/2011/03/12/making-crash-bandicoot-gool-part-9/">Making Crash Bandicoot – GOOL ~ Andy Gavin</a></p>
</section></section>
<section id="y-ahora" class="title-slide slide level1">
<h1>¿Y ahora?</h1>
<p><strong>¿Cómo aprendo LISP?</strong></p>
<p><a href="http://sarabander.github.io/sicp/html/">Structure and Interpretation of Computer Programs</a></p>
<p><a href="https://stevelosh.com/blog/2018/08/a-road-to-common-lisp/">A Road to Common Lisp ~ Steve Losh</a></p>
</section>
    </div>
  </div>

  <script src="./reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: './reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: './reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
